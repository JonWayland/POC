<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="/images/sand_dollar_favicon_64.png" sizes="64x64" type="image/png">
  <title>PDF Annotation Tool | The Dollar Web</title>
      <style>
    /* Inter and Montserrat Fonts */
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 400;
      src: url('/fonts/inter-regular.woff2') format('woff2');
    }
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 500;
      src: url('/fonts/inter-medium.woff2') format('woff2');
    }
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 600;
      src: url('/fonts/inter-semibold.woff2') format('woff2');
    }

    @font-face {
      font-family: 'Montserrat';
      font-style: normal;
      src: url('/fonts/Montserrat-VariableFont_wght.ttf') format('truetype-variations');
      font-weight: 100 900; /* This tells the browser this file contains all weights */
      font-display: swap;
    }

    @font-face {
      font-family: 'Montserrat';
      font-style: italic;
      src: url('/fonts/Montserrat-Italic-VariableFont_wght.ttf') format('truetype-variations');
      font-weight: 100 900;
      font-display: swap;
    }

    :root {
      --primary: #00a896;
      --secondary: #f8b500;
      --accent: #ff6b6b;
      --light: #f8f9fa;
      --dark: #05668d;
      --text: #333;
      --bg: #f5f9f8;
      --highlight: rgba(255, 241, 118, 0.4); /* Default highlight color */
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg);
      color: var(--text);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' opacity='0.03' viewBox='0 0 120 120'%3E%3Cpath d='M20,60 C20,60 35,30 60,30 C85,30 100,60 100,60 C100,60 85,90 60,90 C35,90 20,60 20,60 Z' fill='%2300a896'/%3E%3C/svg%3E");
      background-size: 120px;
      padding-top: 70px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 60px;
    }
    
    header {
      text-align: center;
      padding: 40px 0 0px;
    }
    
    h1 {
      font-family: 'Montserrat', sans-serif;
      font-size: 3.2rem;
      color: var(--primary);
      margin-bottom: 1.2rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      margin-top: 80px;
    }
    
    p.tagline {
      font-size: 1.3rem;
      color: var(--dark);
      max-width: 700px;
      margin: 0 auto 2rem;
      line-height: 1.6;
      font-weight: 300;
    }

    /* Navigation Bar Styles */
    .main-nav {
      background: white;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.08);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 2000;
    }

    .nav-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
    }

    .nav-logo {
      display: flex;
      align-items: center;
      text-decoration: none;
      color: var(--primary);
      font-weight: 600;
      font-size: 1.5rem;
      transition: all 0.2s;
    }

    .nav-logo:hover {
      transform: translateY(-2px);
    }

    .nav-logo svg {
      margin-right: 10px;
    }

    .nav-links {
      display: flex;
      align-items: center;
      gap: 30px;
    }

    .nav-links a {
      color: var(--dark);
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
    }

    .nav-links a:hover {
      color: var(--primary);
    }

    .login-btn {
      background: var(--primary);
      color: white !important;
      padding: 10px 20px;
      border-radius: 8px;
      transition: all 0.2s !important;
    }

    .login-btn:hover {
      background: var(--dark);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    /* Footer Styles */
    .site-footer {
      background: var(--dark);
      padding: 40px 0 50px;
      margin-top: 80px;
      position: relative;
      color: white;
    }

    .footer-wave {
      position: absolute;
      top: -120px;
      left: 0;
      right: 0;
      height: 120px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 120' width='1200' height='120' opacity='0.1'%3E%3Cpath d='M0,100 C200,20 400,60 600,80 C800,100 1000,40 1200,120 L1200,120 L0,120 Z' fill='%23ffffff'/%3E%3C/svg%3E");
      background-repeat: repeat-x;
      background-position: bottom;
    }

    .footer-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .footer-logo {
      display: flex;
      align-items: center;
      margin-bottom: 40px;
      color: var(--secondary);
    }

    .footer-logo svg {
      width: 48px;
      height: 48px;
      margin-right: 16px;
    }

    .footer-logo span {
      font-weight: 600;
      font-size: 2.4rem;
    }

    .footer-links {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 40px;
    }

    .footer-links a {
      color: var(--light);
      text-decoration: none;
      margin: 0 30px;
      font-size: 1.8rem;
      transition: color 0.2s;
    }

    .footer-links a:hover {
      color: var(--secondary);
    }

    .footer-social {
      display: flex;
      gap: 30px;
      margin-bottom: 40px;
    }

    .footer-social a {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      transition: all 0.2s;
    }

    .footer-social a svg {
      width: 40px;
      height: 40px;
    }

    .footer-social a:hover {
      background: var(--secondary);
      color: var(--dark);
      transform: translateY(-3px);
    }

    .copyright {
      font-size: 1.8rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .copyright-message {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .secondary-text {
      color: var(--secondary);
    }
    
    .tertiary-text {
      color: var(--dark);
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .nav-links {
        gap: 15px;
      }
      
      .nav-logo span {
        font-size: 1.2rem;
      }
      
      .footer-links {
        flex-direction: column;
        gap: 20px;
      }
      
      .footer-links a {
        margin: 10px 0;
      }
    }

    @media (max-width: 576px) {
      .nav-links a:not(.login-btn) {
        display: none;
      }
    }

    /* PDF Annotation Specific Styles */
    #toolbar {
      position: fixed;
      top: 70px;
      left: 0;
      right: 0;
      background: white;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      z-index: 1000;
      justify-content: center;
    }
    
    #toolbar * { 
      margin: 4px; 
    }
    
    button {
      padding: 8px 12px;
      border: none;
      background: var(--primary);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    button:hover {
      background: var(--dark);
      transform: translateY(-2px);
    }
    
    button.active {
      background: var(--dark);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    #file-list-container {
      margin-top: 150px;
      padding: 20px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.06);
      margin-bottom: 20px;
      display: none;
      text-align: center;
    }
    
    #file-list {
      list-style: none;
      padding: 0;
      margin: 16px auto;
      max-width: 600px;
    }
    
    #file-list li {
      padding: 12px 16px;
      margin: 8px 0;
      background: var(--bg);
      border-radius: 8px;
      border: 1px solid #ddd;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
    }
    
    #file-list li:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.05);
    }
    
    .file-list-item-content {
      flex-grow: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .remove-file-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 4px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .remove-file-btn:hover {
      background: #ff5252;
      transform: scale(1.1);
    }
    
    .file-list-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 16px;
    }
    
    #load-btn {
      background: var(--secondary);
    }
    
    #load-btn:hover {
      background: #e9a800;
    }
    
    .secondary-btn {
      background: #e0e0e0;
      color: var(--text);
    }
    
    .secondary-btn:hover {
      background: #d0d0d0;
    }
    
    #pages-container {
      margin-top: 70px;
      padding: 40px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 300px;
      border: 2px dashed #bbb;
      border-radius: 16px;
      transition: all 0.3s;
    }
    
    /* Page selection styles */
    .page-selection-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
      display: none;
    }
    
    /* Make the page checkbox container larger and more visible */
    .page-checkbox-container {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 8px;
      z-index: 102; /* Make sure it's above other elements */
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      border: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Style the checkbox itself to be larger */
    .page-checkbox {
      width: 24px;
      height: 24px;
      cursor: pointer;
      accent-color: var(--primary); /* Color the checkbox with the primary theme color */
    }

    /* Add hover effect */
    .page-checkbox-container:hover {
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
      transform: scale(1.05);
      transition: all 0.2s;
    }

    /* Add a label next to the checkbox for better clarity */
    .page-checkbox-container::after {
      content: "Select";
      font-size: 0.9rem;
      margin-left: 6px;
      color: var(--dark);
      font-weight: 500;
    }

    /* Add these styles to show selected state even when not in selection mode */
    .page-container.selected {
      border: 3px solid var(--primary);
      box-shadow: 0 5px 15px rgba(0, 168, 150, 0.2);
    }

    .page-selected-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 168, 150, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: 500;
      z-index: 5;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 0.9rem;
      pointer-events: none; /* Don't interfere with interaction */
      display: flex;
      align-items: center;
    }

    .page-selected-indicator::before {
      content: "âœ“";
      margin-right: 5px;
      font-weight: bold;
    }

    
    .page-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.9rem;
      color: var(--dark);
      z-index: 2;
    }
    
    #pages-container.dragover {
      background: rgba(0, 168, 150, 0.05);
      border-color: var(--primary);
    }
    
    .page-container {
      position: relative;
      margin: 24px 0;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    .os-links a {
      color: var(--primary); text-decoration: none; font-size: 0.9rem;
    }
    .os-links a:hover { text-decoration: underline; }
    
    .pdf-canvas, .annotation-canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .pdf-canvas { z-index: 0; }
    .annotation-canvas { z-index: 1; }
    
    /* Confirmation Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal-container {
      background-color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
      width: 90%;
      max-width: 500px;
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }
    
    .modal-overlay.active .modal-container {
      transform: translateY(0);
    }
    
    .modal-header {
      margin-bottom: 20px;
      text-align: center;
    }
    
    .modal-header h3 {
      font-size: 1.5rem;
      color: var(--dark);
      margin: 0;
    }
    
    .modal-body {
      margin-bottom: 25px;
      text-align: center;
      font-size: 1.1rem;
      color: var(--text);
    }
    
    .modal-footer {
      display: flex;
      justify-content: center;
      gap: 15px;
    }
    
    .modal-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .modal-btn-cancel {
      background-color: #e9ecef;
      color: var(--text);
    }
    
    .modal-btn-cancel:hover {
      background-color: #dee2e6;
    }
    
    .modal-btn-confirm {
      background-color: #f44336;
      color: white;
    }
    
    .modal-btn-confirm:hover {
      background-color: #e53935;
      transform: translateY(-2px);
    }
    
    label {
      display: flex;
      align-items: center;
      font-weight: 500;
    }

    label[for="text-input"], 
    label:has(#text-input) {
      font-weight: 500;
      display: flex;
      align-items: center;
      margin-right: 15px;
    }
    
    input[type="text"], input[type="number"] {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    
    input[type="file"] {
      padding: 8px;
    }
    
    input[type="range"] {
      width: 100px;
    }
    
    #text-input {
      width: 150px;
    }
    
    #font-size {
      width: 60px;
    }
    
    #undo-btn {
      background: var(--accent);
    }
    
    #clear-btn {
      background: #f44336;
    }
    
    #save-btn {
      background: var(--dark);
    }

    #text-input {
      width: 200px;  /* Make it wider */
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-right: 10px;
    }

    #text-input:focus {
      border-color: var(--primary);
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 168, 150, 0.2);
    }

    /* Reordering mode styles */
    #pages-container.reordering .page-container {
      cursor: grab;
      transition: all 0.2s;
      border: 2px dashed transparent;
      position: relative;
      margin-bottom: 40px; /* Add more space between pages in reordering mode */
    }

    #pages-container.reordering .page-container:hover {
      border-color: var(--primary);
      transform: translateY(-5px);
      box-shadow: 0 15px 25px rgba(0, 0, 0, 0.15);
    }

    #pages-container.reordering .page-container.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }

    /* Page number indicator */
    .page-order-indicator {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 168, 150, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: bold;
      z-index: 10;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 0.9rem;
    }

    /* Reorder controls */
    .reorder-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
    }

    /* Style for the reorder button in the toolbar */
    #reorder-pages-btn {
      background: var(--primary);
    }

    #reorder-pages-btn:hover {
      background: var(--dark);
    }

    #reorder-pages-btn.active {
      background: var(--secondary);
    }

    /* Invisible overlay to make entire page draggable */
    #pages-container.reordering .page-container::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 100; /* Place above canvases */
      cursor: grab;
      background: transparent;
      pointer-events: auto; /* Allow interaction */
    }

    #pages-container.reordering .page-container.dragging::after {
      cursor: grabbing;
    }

    /* Update the page-order-indicator to appear above the overlay */
    .page-order-indicator {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 168, 150, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: bold;
      z-index: 101; /* Above the ::after overlay */
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 0.9rem;
    }

    #zoom-in-btn, #zoom-out-btn, #zoom-reset-btn {
      padding: 5px 10px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }

    #zoom-in-btn:hover, #zoom-out-btn:hover, #zoom-reset-btn:hover {
      background: var(--dark);
      transform: translateY(-2px);
    }

    #zoom-level {
      font-weight: 500;
      color: var(--dark);
    }

    button[data-tool="blackout"] {
      background-color: #000;
      color: #fff;
    }

    button[data-tool="blackout"]:hover {
      background-color: #333;
    }

    button[data-tool="blackout"].active {
      background-color: #000;
      box-shadow: 0 0 0 2px #fff, 0 0 0 4px #000;
    }

    button[data-tool="highlight"] {
      background-color: #f8b500;
      color: #fff;
    }

    button[data-tool="highlight"]:hover {
      background-color: #05668d;
    }

    button[data-tool="highlight"].active {
      background-color: #f8b500;
      box-shadow: 0 0 0 2px #fff, 0 0 0 4px #f8b500;
    }

    button[data-tool="text"] {
      background-color: #05668d;
      color: #fff;
    }

    button[data-tool="text"]:hover {
      background-color: #05668d;
    }

    button[data-tool="text"].active {
      background-color: #05668d;
      box-shadow: 0 0 0 2px #fff, 0 0 0 4px #f8b500;
    }

  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="main-nav">
    <div class="container nav-container">
      <a href="index.html" class="nav-logo">
        <img src="images/logo.svg" alt="The Dollar Web Logo" style="width: 32px; height: 32px;">
        <span class="tertiary-text">&nbsp;The&nbsp;</span>Dollar&nbsp;<span class="secondary-text">Web</span>
      </a>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <a href="tools.html">Tools</a>
        <a href="about.html">About</a>
        <a href="login.html" class="login-btn">Login</a>
      </div>
    </div>
  </nav>

  <div class="container">
    <header>
      <h1>PDF Annotation Tool</h1>
      <p class="tagline">Combine or split PDFs. Add notes, highlights, and drawings to your PDF documents. Edit multiple PDFs at once and save your changes.</p>
      <div class="os-links">
        <a href="/licenses.html">Open-source acknowledgements</a>
      </div>
    </header>
    
    <div id="toolbar">
      <input type="file" id="file-input" accept="application/pdf" multiple>
      <button data-tool="select" class="active">Select</button>
      <button data-tool="draw">Draw</button>
      <button data-tool="line">Line</button>
      <button data-tool="highlight">Highlight</button>
      <button data-tool="blackout">Black Out</button>
      <button data-tool="text">Text</button>
      <label>Color: <input type="color" id="color-picker" value="#05668d"></label>
      <label>Size: <input type="range" id="size-slider" min="1" max="20" value="2"></label>
      <label>Font Size: <input type="number" id="font-size" min="10" max="72" value="24"></label>
      <label>Document Title: <input type="text" id="text-input" placeholder="Document title"></label>
      <button id="undo-btn">Undo</button>
      <button id="clear-btn">Clear</button>
      <div style="display: flex; align-items: center; margin-left: 10px;">
        <button id="zoom-out-btn" title="Zoom Out">-</button>
        <span id="zoom-level" style="margin: 0 8px; min-width: 40px; text-align: center;">100%</span>
        <button id="zoom-in-btn" title="Zoom In">+</button>
        <button id="zoom-reset-btn" title="Reset Zoom" style="margin-left: 5px;">Reset</button>
      </div>
      <button id="toggle-selection-btn">Select Pages</button>
      <button id="reorder-pages-btn">Reorder Pages</button>
      <button id="save-btn">Download</button>
    </div>
    
    <div class="page-selection-controls" id="page-selection-controls">
      <button id="select-all-btn">Select All</button>
      <button id="deselect-all-btn">Deselect All</button>
      <span id="selected-count">0 pages selected</span>
    </div>

    <div id="file-list-container">
      <strong>Reorder your PDFs:</strong>
      <ul id="file-list"></ul>
      <div class="file-list-buttons">
        <button id="load-btn">Load PDFs</button>
        <button id="clear-files-btn" class="secondary-btn">Clear All Files</button>
      </div>
    </div>

    <div id="pages-container">
      <p style="color:#666; margin-top:100px; text-align:center; font-size:1.2rem;">
        Drag & drop PDFs here, or use the file input above.<br>
        <br>
        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="12" y1="18" x2="12" y2="12"></line>
          <line x1="9" y1="15" x2="15" y2="15"></line>
        </svg>
      </p>
    </div>
  </div>
  
  <!-- Footer -->
  <footer class="site-footer">
    <div class="footer-wave"></div>
    <div class="footer-content">
      <div class="footer-logo">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
          <polyline points="9 22 9 12 15 12 15 22"></polyline>
        </svg>
        <span>The DollarWeb</span>
      </div>
      <div class="footer-links">
        <a href="index.html">Home</a>
        <a href="#">About</a>
        <a href="#">Contact</a>
        <a href="#">Privacy Policy</a>
        <a href="#">Terms of Service</a>
      </div>
      <div class="footer-social">
        <a href="https://x.com/thedollarweb" aria-label="Twitter">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Z"/>
          </svg>
        </a>
        <!--
        <a href="#" aria-label="Facebook">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>
          </svg>
        </a>
        -->
        <a href="https://www.instagram.com/thedollarwebpro/" aria-label="Instagram">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
            <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
            <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
          </svg>
        </a>
        <a href="https://www.linkedin.com/company/the-dollar-web" aria-label="LinkedIn">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
            <rect x="2" y="9" width="4" height="12"></rect>
            <circle cx="4" cy="4" r="2"></circle>
          </svg>
        </a>
      </div>
      <p class="copyright">&copy; 2025 The DollarWeb</p>
      <p class="copyright-message">Professional tools that won't break the bank</p>
    </div>
  </footer>

  <!-- Confirmation Modals -->
  <div class="modal-overlay" id="confirmation-modal">
    <div class="modal-container">
      <div class="modal-header">
        <h3>Clear All Annotations?</h3>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to clear all annotations? This action cannot be undone.</p>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="cancel-clear">Cancel</button>
        <button class="modal-btn modal-btn-confirm" id="confirm-clear">Clear All</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="clear-files-modal">
    <div class="modal-container">
      <div class="modal-header">
        <h3>Clear All Files?</h3>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to remove all PDF files from the list? This will not affect any loaded PDFs that you're currently annotating.</p>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="cancel-clear-files">Cancel</button>
        <button class="modal-btn modal-btn-confirm" id="confirm-clear-files">Clear All Files</button>
      </div>
    </div>
  </div>
  
  <!-- libs -->
  <script src="/libs/pdf.min.js"></script>
  <script src="/libs/pdf.worker.min.js"></script>
  <script src="/libs/fabric.min.js"></script>
  <script src="/libs/jspdf.umd.min.js"></script>
  <script src="/libs/Sortable.min.js"></script>

  <script>
    // PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      '/libs/pdf.worker.min.js';

    // DOM refs
    const fileInput          = document.getElementById('file-input');
    const fileListCont       = document.getElementById('file-list-container');
    const fileListEl         = document.getElementById('file-list');
    const loadBtn            = document.getElementById('load-btn');
    const clearFilesBtn      = document.getElementById('clear-files-btn');
    const pagesContainer     = document.getElementById('pages-container');
    const toolButtons        = document.querySelectorAll('#toolbar button[data-tool]');
    const colorPicker        = document.getElementById('color-picker');
    const sizeSlider         = document.getElementById('size-slider');
    const fontSizeInput      = document.getElementById('font-size');
    const textInput          = document.getElementById('text-input');
    const undoBtn            = document.getElementById('undo-btn');
    const clearBtn           = document.getElementById('clear-btn');
    const saveBtn            = document.getElementById('save-btn');
    const toggleSelectionBtn = document.getElementById('toggle-selection-btn');
    const selectAllBtn       = document.getElementById('select-all-btn');
    const deselectAllBtn     = document.getElementById('deselect-all-btn');
    const selectedCountEl    = document.getElementById('selected-count');
    const pageSelectionCtrls = document.getElementById('page-selection-controls');

    // state
    let currentTool       = 'select';
    let fabricCanvases    = [];
    let pdfCanvases       = [];
    let lastFocusedCanvas = null;
    let fileBlobs         = [];
    let selectionMode     = false;
    let undoHistory       = []; // Track actions for undo functionality
    let originalPageOrder = []; // To track original page order during reordering
    let objectHistory = []; // objectHistory array
    // Zoom state variables
    let currentZoomIndex = 3; // Start at 100%
    const zoomLevels = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0];

    // init Sortable on file list
    Sortable.create(fileListEl, { animation: 150 });

    // Add the reorder button initialization here
    const reorderPagesBtn = document.getElementById('reorder-pages-btn');
    let reorderingMode = false;
    let sortablePages = null;

    // Reorder mode toggle functionality
    reorderPagesBtn.addEventListener('click', toggleReorderMode);

    // tool switching
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
        updateToolMode();
      });
    });

    function updateToolMode() {
      fabricCanvases.forEach(fc => {
        // Set drawing mode only if current tool is draw
        fc.isDrawingMode = (currentTool === 'draw');
        
        // Allow selection only in select mode
        fc.selection = (currentTool === 'select');
        
        // Change cursor based on tool
        if (currentTool === 'select') {
          fc.defaultCursor = 'default';
        } else if (currentTool === 'highlight') {
          fc.defaultCursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23000000\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3E%3Cpath d=\'M12 20h9\'%3E%3C/path%3E%3Cpath d=\'M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z\'%3E%3C/path%3E%3C/svg%3E") 1 17, auto';
        } else if (currentTool === 'blackout') {
          fc.defaultCursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'%23000000\' stroke=\'%23ffffff\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3E%3Crect x=\'3\' y=\'3\' width=\'18\' height=\'18\' rx=\'2\' ry=\'2\'%3E%3C/rect%3E%3C/svg%3E") 1 17, auto';
        } else {
          fc.defaultCursor = 'crosshair';
        }
        
        // Update brush properties
        fc.freeDrawingBrush.width = +sizeSlider.value;
        fc.freeDrawingBrush.color = colorPicker.value;
        
        // Update objects selectability
        fc.getObjects().forEach(o => {
          o.selectable = (currentTool === 'select');
          o.evented = true; // Make sure objects respond to events
        });
        
        // Important for multi-select: Enable group selection
        if (currentTool === 'select') {
          fc.preserveObjectStacking = true; // Maintains z-index during selection
          fc.uniScaleTransform = false; // Allows non-uniform scaling
        }
        
        fc.renderAll();
      });
    }

    function initializeMultiSelect() {
      if (currentTool === 'select') {
        fabricCanvases.forEach(fc => {
          // Ensure selection mode is enabled
          fc.selection = true;
          
          // Make sure objects can be selected
          fc.getObjects().forEach(obj => {
            obj.selectable = true;
            obj.evented = true;
          });
          
          // Enable multiple selection with selection boxes
          fc.selectionFullyContained = false; // Select objects even if partly in selection
          
          // Ensure canvas knows when it's active
          fc.on('mouse:down', function() {
            lastFocusedCanvas = fc;
          });
          
          fc.renderAll();
        });
      }
    }

    // Undo / Clear
    undoBtn.addEventListener('click', () => {
      // Check if there's anything to undo
      if (objectHistory.length === 0) return;
      
      // Get the most recent action
      const lastAction = objectHistory.pop();
      
      // Find the corresponding canvas
      const fc = fabricCanvases[lastAction.canvasIndex];
      if (!fc) return; // Safety check
      
      // Handle the action based on its type
      if (lastAction.type === 'add') {
        // If the object is still on the canvas, remove it
        if (fc.contains(lastAction.object)) {
          fc.remove(lastAction.object);
        }
      } else if (lastAction.type === 'modify') {
        // If the object is still on the canvas, restore its previous state
        if (lastAction.object && fc.contains(lastAction.object)) {
          Object.keys(lastAction.oldState).forEach(prop => {
            lastAction.object.set(prop, lastAction.oldState[prop]);
          });
          lastAction.object.setCoords();
        }
      } else if (lastAction.type === 'clear') {
        // Restore objects after a clear
        if (Array.isArray(lastAction.objects)) {
          lastAction.objects.forEach(obj => {
            // If the object is a serialized json object, recreate it
            if (typeof obj === 'object' && !obj.canvas) {
              // Recreate from serialized object
              fabric.util.enlivenObjects([obj], function(enlivenedObjects) {
                if (enlivenedObjects && enlivenedObjects[0]) {
                  fc.add(enlivenedObjects[0]);
                }
              });
            } else {
              // It's a direct object reference
              fc.add(obj);
            }
          });
        }
      }
      
      // Render the changes
      fc.renderAll();
      
      // Set this as the last focused canvas
      lastFocusedCanvas = fc;
      
      // Debug the remaining history
      console.log(`Undo performed. Remaining history items: ${objectHistory.length}`);
    });
    
    // Clear button - show confirmation modal
    const confirmationModal = document.getElementById('confirmation-modal');
    const cancelClearBtn = document.getElementById('cancel-clear');
    const confirmClearBtn = document.getElementById('confirm-clear');
    
    clearBtn.addEventListener('click', () => {
      // Show the confirmation modal
      confirmationModal.classList.add('active');
    });
    
    // Cancel button in modal
    cancelClearBtn.addEventListener('click', () => {
      confirmationModal.classList.remove('active');
    });
    
    // Confirm button in modal
    confirmClearBtn.addEventListener('click', () => {
      // Hide the modal
      confirmationModal.classList.remove('active');
      
      // Save objects for undo before clearing
      fabricCanvases.forEach(fc => {
        if (fc.getObjects().length > 0) {
          // Store a deep clone of all objects for undo
          const objectClones = [];
          fc.getObjects().forEach(obj => {
            // Create a serialized copy
            const json = obj.toJSON();
            objectClones.push(json);
          });
          
          // Add to undo history
          objectHistory.push({
            canvasIndex: fabricCanvases.indexOf(fc),
            type: 'clear',
            objects: objectClones,
            objectCount: fc.getObjects().length
          });
          
          // Clear the canvas
          fc.clear();
        }
      });
    });
    
    // Close modal if clicked outside
    confirmationModal.addEventListener('click', (e) => {
      if (e.target === confirmationModal) {
        confirmationModal.classList.remove('active');
      }
    });
    
    // Clear files button - show confirmation modal
    const clearFilesModal = document.getElementById('clear-files-modal');
    const cancelClearFilesBtn = document.getElementById('cancel-clear-files');
    const confirmClearFilesBtn = document.getElementById('confirm-clear-files');
    
    clearFilesBtn.addEventListener('click', () => {
      // Show the confirmation modal
      clearFilesModal.classList.add('active');
    });
    
    // Cancel button in modal
    cancelClearFilesBtn.addEventListener('click', () => {
      clearFilesModal.classList.remove('active');
    });
    
    // Confirm button in modal
    confirmClearFilesBtn.addEventListener('click', () => {
      // Hide the modal
      clearFilesModal.classList.remove('active');
      
      // Clear all files
      fileBlobs = [];
      setupFileList();
    });
    
    // Close modal if clicked outside
    clearFilesModal.addEventListener('click', (e) => {
      if (e.target === clearFilesModal) {
        clearFilesModal.classList.remove('active');
      }
    });
    
    // Add keyboard event listeners for delete/backspace
    document.addEventListener('keydown', (e) => {
      // Check if Escape key was pressed (for modals)
      if (e.key === 'Escape') {
        if (confirmationModal.classList.contains('active')) {
          confirmationModal.classList.remove('active');
        }
        if (clearFilesModal.classList.contains('active')) {
          clearFilesModal.classList.remove('active');
        }
        return;
      }
      
      // Check if Delete or Backspace was pressed
      if (e.key === 'Delete' || e.key === 'Backspace') {
        // Only process if we're not in a text field
        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
          // Find the canvas that has the active selection
          const activeCanvas = fabricCanvases.find(fc => {
            return fc.getActiveObject() !== null;
          });
          
          if (activeCanvas) {
            const activeObj = activeCanvas.getActiveObject();
            if (activeObj) {
              // For multiple object selection
              if (activeObj.type === 'activeSelection') {
                // Get all objects in the selection
                const objectsToRemove = activeObj.getObjects();
                
                // Store each object in the undo history before removing
                objectsToRemove.forEach(obj => {
                  objectHistory.push({
                    canvasIndex: fabricCanvases.indexOf(activeCanvas),
                    type: 'add',
                    object: obj
                  });
                });
                
                // Discarding the group selection first
                activeCanvas.discardActiveObject();
                
                // Then remove each object individually
                objectsToRemove.forEach(obj => {
                  activeCanvas.remove(obj);
                });
                
                // Update the canvas
                activeCanvas.requestRenderAll();
              } else {
                // Single object deletion
                objectHistory.push({
                  canvasIndex: fabricCanvases.indexOf(activeCanvas),
                  type: 'add',
                  object: activeObj
                });
                
                // Remove the object
                activeCanvas.remove(activeObj);
              }
              
              e.preventDefault(); // Prevent browser back navigation on backspace
            }
          }
        }
      }
    });

    // Save PDF with selected pages
    saveBtn.addEventListener('click', async () => {
      const { jsPDF } = window.jspdf;
      if (!pdfCanvases.length) return;
      
      // Get all page containers in their current display order
      const pageContainers = Array.from(document.querySelectorAll('.page-container'));
      
      // Get selected pages (if selection mode is active)
      let selectedContainers = [];
      const checkboxes = document.querySelectorAll('.page-checkbox:checked');
      
      // If we have checkboxes and some are checked, use selection
      if (checkboxes.length > 0) {
        checkboxes.forEach(cb => {
          const container = cb.closest('.page-container');
          if (container) {
            selectedContainers.push(container);
          }
        });
      } else {
        // Otherwise include all pages in their current order
        selectedContainers = pageContainers;
      }
      
      if (selectedContainers.length === 0) {
        alert('Please select at least one page to save.');
        return;
      }
      
      // Get the document title from the text input
      let fileName = document.getElementById('text-input').value.trim();
      
      // If no title is provided, use a default
      if (fileName === '') {
        fileName = 'annotated.pdf';
      } else {
        // Ensure the filename ends with .pdf
        if (!fileName.toLowerCase().endsWith('.pdf')) {
          fileName += '.pdf';
        }
      }
      
      // Show a loading indicator
      const loadingDiv = document.createElement('div');
      loadingDiv.style.position = 'fixed';
      loadingDiv.style.top = '50%';
      loadingDiv.style.left = '50%';
      loadingDiv.style.transform = 'translate(-50%, -50%)';
      loadingDiv.style.padding = '20px 40px';
      loadingDiv.style.background = 'rgba(0, 0, 0, 0.7)';
      loadingDiv.style.color = 'white';
      loadingDiv.style.borderRadius = '10px';
      loadingDiv.style.zIndex = '9999';
      loadingDiv.style.fontSize = '18px';
      loadingDiv.textContent = 'Creating PDF...';
      document.body.appendChild(loadingDiv);
      
      // Store current zoom index to restore later
      const savedZoomIndex = currentZoomIndex;
      
      // Temporarily set zoom to 100% for rendering
      if (currentZoomIndex !== 3) { // If not already at 100%
        currentZoomIndex = 3; // Index 3 is 100%
        applyZoom(zoomLevels[currentZoomIndex]);
      }
      
      // Wait for zoom changes to take effect
      setTimeout(async () => {
        try {
          // Start with first selected page's size/orientation
          const firstContainer = selectedContainers[0];
          const firstPdfCanvas = firstContainer.querySelector('.pdf-canvas');
          
          // Get original dimensions (before zoom was applied)
          const originalWidth = firstPdfCanvas.originalWidth || firstPdfCanvas.width;
          const originalHeight = firstPdfCanvas.originalHeight || firstPdfCanvas.height;
          
          const orient = originalWidth > originalHeight ? 'l' : 'p';
          const doc = new jsPDF({ 
            unit: 'px', 
            format: [originalWidth, originalHeight], 
            orientation: orient 
          });
          
          // First page is already added by jsPDF constructor
          let currentPage = 1;
          
          for (let i = 0; i < selectedContainers.length; i++) {
            const container = selectedContainers[i];
            const pdfCanvas = container.querySelector('.pdf-canvas');
            const annotationWrapper = container.querySelector('.canvas-container');
            
            // Find the correct fabric canvas
            const fabricCanvas = fabricCanvases.find(fc => fc.wrapperEl === annotationWrapper);
            
            if (!pdfCanvas || !fabricCanvas) {
              console.error('Could not find canvas elements for page', i);
              continue;
            }
            
            // Get original dimensions for this page
            const pageOrigWidth = pdfCanvas.originalWidth || pdfCanvas.width;
            const pageOrigHeight = pdfCanvas.originalHeight || pdfCanvas.height;
            
            // Add a new page for all pages after the first one
            if (i > 0) {
              const o = pageOrigWidth > pageOrigHeight ? 'l' : 'p';
              doc.addPage([pageOrigWidth, pageOrigHeight], o);
              currentPage++;
            }
            
            // Set active page
            doc.setPage(currentPage);
            
            // Create a temporary canvas for composition
            const tmp = document.createElement('canvas');
            tmp.width = pageOrigWidth;
            tmp.height = pageOrigHeight;
            const ctx = tmp.getContext('2d');
            
            // Draw the PDF background
            ctx.drawImage(pdfCanvas, 0, 0, pdfCanvas.width, pdfCanvas.height, 
                        0, 0, pageOrigWidth, pageOrigHeight);
            
            // Use fabric's toDataURL to render all objects correctly
            const fabricData = fabricCanvas.toDataURL({
              format: 'png',
              quality: 1.0,
              multiplier: 1.0,
              enableRetinaScaling: true,
              width: pageOrigWidth,
              height: pageOrigHeight
            });
            
            // Create an image from the fabric canvas data
            const img = new Image();
            await new Promise((resolve, reject) => {
              img.onload = resolve;
              img.onerror = reject;
              img.src = fabricData;
            });
            
            // Draw the fabric canvas on top of the PDF canvas
            ctx.drawImage(img, 0, 0);
            
            // Add the combined image to the PDF
            doc.addImage(
              tmp.toDataURL('image/png', 1.0), 
              'PNG', 
              0, 0, 
              pageOrigWidth, 
              pageOrigHeight
            );
            
            // Update loading indicator
            loadingDiv.textContent = `Creating PDF... (Page ${i+1}/${selectedContainers.length})`;
          }
          
          // Save the PDF
          doc.save(fileName);
        } catch (error) {
          console.error('Error creating PDF:', error);
          alert('There was an error creating the PDF. Please try again.');
        } finally {
          // Restore the original zoom
          if (savedZoomIndex !== currentZoomIndex) {
            currentZoomIndex = savedZoomIndex;
            applyZoom(zoomLevels[currentZoomIndex]);
          }
          
          // Remove loading indicator
          document.body.removeChild(loadingDiv);
        }
      }, 500); // Longer timeout to ensure zoom changes are fully applied
    });

    // brush settings updates
    colorPicker.addEventListener('change', updateToolMode);
    sizeSlider.addEventListener('input', updateToolMode);
    
    // Update the toggleSelectionBtn click handler to maintain visual selection state
    toggleSelectionBtn.addEventListener('click', () => {
      selectionMode = !selectionMode;
      toggleSelectionBtn.textContent = selectionMode ? 'Exit Selection Mode' : 'Select Pages';
      toggleSelectionBtn.style.background = selectionMode ? 'var(--secondary)' : '';
      pageSelectionCtrls.style.display = selectionMode ? 'flex' : 'none';
      
      // Show/hide checkboxes for all pages
      const pageContainers = document.querySelectorAll('.page-container');
      pageContainers.forEach((container, index) => {
        let checkbox = container.querySelector('.page-checkbox-container');
        
        if (selectionMode) {
          // Create checkbox if it doesn't exist
          if (!checkbox) {
            checkbox = document.createElement('div');
            checkbox.className = 'page-checkbox-container';
            
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.className = 'page-checkbox';
            cb.id = `page-checkbox-${index}`;
            cb.dataset.pageIndex = index;
            cb.checked = container.classList.contains('selected') || true; // Default to selected or use previous state
            
            // Update the visual indicator whenever checkbox changes
            cb.addEventListener('change', (e) => {
              updateSelectedCount();
              
              // Update the container's selected class
              if (e.target.checked) {
                container.classList.add('selected');
              } else {
                container.classList.remove('selected');
                
                // Remove visual indicator if present
                const indicator = container.querySelector('.page-selected-indicator');
                if (indicator) {
                  indicator.remove();
                }
              }
            });
            
            // Add label for better accessibility
            const label = document.createElement('label');
            label.htmlFor = `page-checkbox-${index}`;
            label.className = 'page-checkbox-label';
            label.appendChild(cb);
            
            checkbox.appendChild(label);
            container.appendChild(checkbox);
            
            // Add animation to draw attention
            checkbox.style.opacity = '0';
            checkbox.style.transform = 'scale(0.8)';
            checkbox.style.transition = 'all 0.3s ease';
            
            // Force reflow to make the animation work
            void checkbox.offsetWidth;
            
            // Animate in
            checkbox.style.opacity = '1';
            checkbox.style.transform = 'scale(1)';
            
            // Add page number indicator
            const pageInfo = document.createElement('div');
            pageInfo.className = 'page-info';
            pageInfo.textContent = `Page ${index + 1}`;
            container.appendChild(pageInfo);
            
            // Mark as selected initially (since checkbox is checked by default)
            container.classList.add('selected');
          } else {
            // Show existing checkbox
            checkbox.style.display = 'flex';
            
            // Update page info
            const pageInfo = container.querySelector('.page-info');
            if (pageInfo) pageInfo.style.display = 'block';
          }
        } else if (checkbox) {
          // Hide checkbox when not in selection mode
          checkbox.style.display = 'none';
          
          // Hide page info
          const pageInfo = container.querySelector('.page-info');
          if (pageInfo) pageInfo.style.display = 'none';
          
          // Check if this page is selected
          const cb = checkbox.querySelector('.page-checkbox');
          if (cb && cb.checked) {
            // Keep the container's selected class
            container.classList.add('selected');
            
            // Add a visual indicator that this page is selected
            if (!container.querySelector('.page-selected-indicator')) {
              const indicator = document.createElement('div');
              indicator.className = 'page-selected-indicator';
              indicator.textContent = 'Selected';
              container.appendChild(indicator);
            }
          } else {
            // Remove selected class and indicator
            container.classList.remove('selected');
            const indicator = container.querySelector('.page-selected-indicator');
            if (indicator) {
              indicator.remove();
            }
          }
        }
      });
      
      updateSelectedCount();

      // Preserve current zoom level when toggling selection mode
      if (currentZoomIndex !== 3) { // If not at default 100%
        applyZoom(zoomLevels[currentZoomIndex]);
      }
    });
    
    // Select/Deselect All
    selectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = true;
        
        // Update visual state
        const container = cb.closest('.page-container');
        if (container) {
          container.classList.add('selected');
        }
      });
      updateSelectedCount();
    });
    
    deselectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = false;
        
        // Update visual state
        const container = cb.closest('.page-container');
        if (container) {
          container.classList.remove('selected');
          
          // Remove any selection indicators
          const indicator = container.querySelector('.page-selected-indicator');
          if (indicator) {
            indicator.remove();
          }
        }
      });
      updateSelectedCount();
    });
    
    // Update the selected count
    function updateSelectedCount() {
      const total = document.querySelectorAll('.page-checkbox').length;
      const selected = document.querySelectorAll('.page-checkbox:checked').length;
      selectedCountEl.textContent = `${selected} of ${total} pages selected`;
    }

    // handle file input (multiple)
    fileInput.addEventListener('change', e => {
      const newFiles = Array.from(e.target.files).filter(f => f.type === 'application/pdf');
      if (newFiles.length > 0) {
        // Add new files to existing files array
        fileBlobs = [...fileBlobs, ...newFiles];
        setupFileList();
      }
    });

    // drag & drop to file list
    // Define named event handler functions
    const pagesContainerDragOver = function(e) {
      e.preventDefault();
      pagesContainer.classList.add('dragover');
    };

    const pagesContainerDragLeave = function() {
      pagesContainer.classList.remove('dragover');
    };

    const pagesContainerDrop = function(e) {
      e.preventDefault();
      pagesContainer.classList.remove('dragover');
      const dropped = Array.from(e.dataTransfer.files)
                          .filter(f => f.type === 'application/pdf');
      if (!dropped.length) {
        alert('Please drop PDF files only.');
        return;
      }
      
      // Add new files to existing files array instead of replacing
      fileBlobs = [...fileBlobs, ...dropped];
      setupFileList();
    };

    // Add event listeners using the named functions
    pagesContainer.addEventListener('dragover', pagesContainerDragOver);
    pagesContainer.addEventListener('dragleave', pagesContainerDragLeave);
    pagesContainer.addEventListener('drop', pagesContainerDrop);

    // populate & show the file-list
    function setupFileList() {
      fileListEl.innerHTML = '';
      fileBlobs.forEach((f, i) => {
        const li = document.createElement('li');
        
        // Create wrapper for file name that can be truncated
        const fileNameWrapper = document.createElement('div');
        fileNameWrapper.className = 'file-list-item-content';
        fileNameWrapper.textContent = f.name;
        li.appendChild(fileNameWrapper);
        
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-file-btn';
        removeBtn.innerHTML = 'Ã—'; // Ã— character
        removeBtn.title = 'Remove this PDF';
        removeBtn.dataset.index = i;
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent triggering sortable
          const index = parseInt(e.target.dataset.index);
          removePdfFile(index);
        });
        li.appendChild(removeBtn);
        
        li.dataset.index = i;
        fileListEl.appendChild(li);
      });
      
      // Show the file list container if we have files
      if (fileBlobs.length > 0) {
        fileListCont.style.display = 'block';
        pagesContainer.innerHTML = '<p style="color:#666;margin-top:100px;text-align:center;font-size:1.2rem;">Drag & drop more PDFs here, or Reorder above and click Load PDFs.</p>';
      } else {
        // Hide the container if all files were removed
        fileListCont.style.display = 'none';
        pagesContainer.innerHTML = '<p style="color:#666; margin-top:100px; text-align:center; font-size:1.2rem;">' +
          'Drag & drop PDFs here, or use the file input above.<br>' +
          '<br>' +
          '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">' +
          '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>' +
          '<polyline points="14 2 14 8 20 8"></polyline>' +
          '<line x1="12" y1="18" x2="12" y2="12"></line>' +
          '<line x1="9" y1="15" x2="15" y2="15"></line>' +
          '</svg>' +
          '</p>';
      }
    }
    
    // Function to remove a PDF file from the list
    function removePdfFile(index) {
      // Remove the file from the array
      fileBlobs.splice(index, 1); // Fixed: This removes one element at position 'index'
      
      // Update the UI
      setupFileList();
      
      // Update data-index attributes on remove buttons to match new array indexes
      document.querySelectorAll('.remove-file-btn').forEach((btn, i) => {
        btn.dataset.index = i;
      });
      
      // Update data-index attributes on list items
      document.querySelectorAll('#file-list li').forEach((li, i) => {
        li.dataset.index = i;
      });
    }

    // when user clicks Load, render in the chosen order
    loadBtn.addEventListener('click', () => {
      if (fileBlobs.length === 0) {
        alert('Please add at least one PDF file before loading.');
        return;
      }
      
      const ordered = Array.from(fileListEl.children).map(li => fileBlobs[li.dataset.index]);
      renderMultiplePDFs(ordered);
    });

    // render 1+ PDFs in sequence
    async function renderMultiplePDFs(files) {
      pagesContainer.innerHTML = '';
      fabricCanvases = [];
      pdfCanvases = [];
      lastFocusedCanvas = null;
      
      // Reset selection mode
      selectionMode = false;
      toggleSelectionBtn.textContent = 'Select Pages';
      toggleSelectionBtn.style.background = '';
      pageSelectionCtrls.style.display = 'none';

      for (const file of files) {
        const url = URL.createObjectURL(file);
        const pdf = await pdfjsLib.getDocument(url).promise;
        for (let p = 1; p <= pdf.numPages; p++) {
          const page = await pdf.getPage(p);
          const vp   = page.getViewport({ scale: 1.5 });

          // container for this page
          const wrapper = document.createElement('div');
          wrapper.className = 'page-container';
          wrapper.style.width  = vp.width + 'px';
          wrapper.style.height = vp.height + 'px';

          // PDF layer
          const pdfCanv = document.createElement('canvas');
          pdfCanv.className = 'pdf-canvas';
          pdfCanv.width  = vp.width;
          pdfCanv.height = vp.height;
          wrapper.appendChild(pdfCanv);
          // Store the PDF page reference for zoom functionality
          pdfCanv.pdfPage = page;
          await page.render({ canvasContext: pdfCanv.getContext('2d'), viewport: vp }).promise;
          pdfCanvases.push(pdfCanv);

          // annotation layer
          const annCanv = document.createElement('canvas');
          annCanv.className = 'annotation-canvas';
          annCanv.width  = vp.width;
          annCanv.height = vp.height;
          wrapper.appendChild(annCanv);

          pagesContainer.appendChild(wrapper);
          const fc = new fabric.Canvas(annCanv, { selection: false });
          fabricCanvases.push(fc);

          // Selection configuration
          fc.selectionKey = 'shiftKey';
          fc.selectionColor = 'rgba(0, 168, 150, 0.2)';
          fc.selectionBorderColor = 'rgba(0, 168, 150, 0.8)';
          fc.selectionLineWidth = 1;

          // EVENT LISTENERS
          // For free drawing (paths)
          fc.on('path:created', function(e) {
            // When a drawing path is created, add it to the history
            objectHistory.push({
              canvasIndex: fabricCanvases.indexOf(fc),
              type: 'add',
              object: e.path
            });
          });

          // For all other object additions (text, lines, highlights, etc.)
          fc.on('object:added', function(e) {
            // Avoid duplicating path objects (which trigger both events)
            if (e.target.type !== 'path' || e.target.source !== 'pencil') {
              objectHistory.push({
                canvasIndex: fabricCanvases.indexOf(fc),
                type: 'add',
                object: e.target
              });
            }
          });

          // For object modifications (move, resize, etc.)
          fc.on('object:modified', function(e) {
            objectHistory.push({
              canvasIndex: fabricCanvases.indexOf(fc),
              type: 'modify',
              object: e.target,
              oldState: e.target.originalState || {}
            });
          });

          // per-canvas handlers
          fc.on('mouse:down', opt => {
            lastFocusedCanvas = fc;
            const pt = fc.getPointer(opt.e, true);

              // Check if we're clicking on an existing object
              if (opt.target && opt.target.selectable) {
                // We're clicking on a selectable object, temporarily switch to select mode
                // regardless of current tool
                fc._tempPreviousTool = currentTool;
                
                // Enable object movement
                opt.target.set({
                  hasControls: true,
                  selectable: true,
                  evented: true
                });
                
                return; // Skip the rest of the function to prevent creating new objects
              }
              
              // Restore previous tool if we were in temporary select mode
              if (fc._tempPreviousTool) {
                fc._tempPreviousTool = null;
              }
            
            if (currentTool === 'line') {
              // Create a new line and add it to the canvas
              fc._line = new fabric.Line([pt.x, pt.y, pt.x, pt.y], {
                stroke: colorPicker.value,
                strokeWidth: +sizeSlider.value,
                selectable: true // Make selectable so it can be modified later
              });
              fc.add(fc._line);
              
              // Note: no need to manually add to objectHistory - object:added event handles this
            } else if (currentTool === 'text') {
                // Create a new text object with empty text
                const txt = new fabric.IText('', {
                  left: pt.x, 
                  top: pt.y,
                  fill: colorPicker.value,
                  fontSize: +fontSizeInput.value,
                  selectable: true,
                  placeholder: 'Enter text here' // Add a placeholder property
                });
                
                // Add to canvas and set as active object
                fc.add(txt);
                fc.setActiveObject(txt);
                
                // Enter editing mode and focus
                txt.enterEditing();
                if (txt.hiddenTextarea) {
                  txt.hiddenTextarea.focus();
                  
                  // Set a temporary placeholder text that will be removed on first keystroke
                  if (txt.text === '') {
                    txt.text = 'Enter text here';
                    txt._isPlaceholder = true; // Flag to identify it as placeholder
                    txt._isEmpty = true; // Flag to track if user has entered any text
                    
                    // Style placeholder text differently (lighter color)
                    const originalFill = txt.fill;
                    txt.set('fill', 'rgba(100, 100, 100, 0.7)');
                    fc.renderAll();
                    
                    // Add one-time event listener for keydown to clear placeholder
                    txt.hiddenTextarea.addEventListener('keydown', function clearPlaceholder(e) {
                      // Don't clear on special keys like shift, ctrl, alt, etc.
                      if (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete') {
                        // Only clear if this is still placeholder text
                        if (txt._isPlaceholder) {
                          // Clear the placeholder text before the key's character is added
                          txt.text = '';
                          txt.set('fill', originalFill); // Restore original text color
                          txt._isPlaceholder = false;
                          fc.renderAll();
                        }
                        
                        // Mark as not empty if user actually typed something
                        if (e.key.length === 1) {
                          txt._isEmpty = false;
                        }
                        
                        // Remove this event listener after first use
                        txt.hiddenTextarea.removeEventListener('keydown', clearPlaceholder);
                      }
                    }, { once: false }); // We manually remove it after use
                    
                    // Add event listener for when text editing ends
                    txt.on('editing:exited', function() {
                      // If text is empty or still has placeholder, remove the object
                      if (txt._isEmpty || txt._isPlaceholder || txt.text === '' || txt.text === 'Enter text here') {
                        // Remove from undo history if it exists there
                        objectHistory = objectHistory.filter(item => 
                          !(item.type === 'add' && item.object === txt)
                        );
                        
                        // Remove from canvas
                        fc.remove(txt);
                        fc.renderAll();
                      }
                    });
                  }
                }
              } else if (currentTool === 'highlight') {
              // Start drawing a highlight rectangle
              fc._highlightStart = pt;
              
              // Create a semi-transparent highlight rectangle
              const color = colorPicker.value;
              let opacity = 0.3; // Default highlight opacity
              
              // Create the highlight rectangle
              fc._highlight = new fabric.Rect({
                left: pt.x,
                top: pt.y,
                width: 0,
                height: 0,
                fill: color,
                opacity: opacity,
                selectable: true
              });
              
              // Add it to the canvas
              fc.add(fc._highlight);
            } else if (currentTool === 'blackout') {
                // Start drawing a black out rectangle
                fc._blackoutStart = pt;
                
                // Create a solid black rectangle
                // Create the black out rectangle
                fc._blackout = new fabric.Rect({
                  left: pt.x,
                  top: pt.y,
                  width: 0,
                  height: 0,
                  fill: '#000000', // Always black, regardless of color picker
                  opacity: 1.0,    // Fully opaque
                  selectable: true
                });
                
                // Add it to the canvas
                fc.add(fc._blackout);
              }
          });
          
          fc.on('mouse:move', opt => {
            if (!opt.e.buttons) return; // Only process if mouse button is pressed
            
            const pt = fc.getPointer(opt.e, true);
            
            if (currentTool === 'line' && fc._line) {
              // Update the endpoint of the line
              fc._line.set({ 
                x2: pt.x, 
                y2: pt.y 
              });
              fc.renderAll();
            } else if (currentTool === 'highlight' && fc._highlight && fc._highlightStart) {
              // Calculate width and height based on start point and current point
              const width = Math.abs(pt.x - fc._highlightStart.x);
              const height = Math.abs(pt.y - fc._highlightStart.y);
              
              // Set the top-left corner of the rectangle
              const left = Math.min(fc._highlightStart.x, pt.x);
              const top = Math.min(fc._highlightStart.y, pt.y);
              
              // Update the highlight rectangle
              fc._highlight.set({
                left: left,
                top: top,
                width: width,
                height: height
              });
              
              fc.renderAll();
            } else if (currentTool === 'blackout' && fc._blackout && fc._blackoutStart) {
                // Calculate width and height based on start point and current point
                const width = Math.abs(pt.x - fc._blackoutStart.x);
                const height = Math.abs(pt.y - fc._blackoutStart.y);
                
                // Set the top-left corner of the rectangle
                const left = Math.min(fc._blackoutStart.x, pt.x);
                const top = Math.min(fc._blackoutStart.y, pt.y);
                
                // Update the black out rectangle
                fc._blackout.set({
                  left: left,
                  top: top,
                  width: width,
                  height: height
                });
                
                fc.renderAll();
              }
          });
          
          fc.on('mouse:up', () => {
            if (currentTool === 'line' && fc._line) { 
              // Finalize the line
              fc._line.setCoords();
              
              // Mark the state as modified to support undo
              fc.fire('object:modified', { target: fc._line });
              
              // Clean up the temporary reference
              fc._line = null;
            }
            
            if (currentTool === 'highlight' && fc._highlight) {
              // Finalize the highlight
              fc._highlight.setCoords();
              
              // Mark the state as modified to support undo
              fc.fire('object:modified', { target: fc._highlight });
              
              // Clean up temporary variables
              fc._highlight = null;
              fc._highlightStart = null;
            }
            if (currentTool === 'blackout' && fc._blackout) {
              // Finalize the black out rectangle
              fc._blackout.setCoords();
              
              // Mark the state as modified to support undo
              fc.fire('object:modified', { target: fc._blackout });
              
              // Clean up temporary variables
              fc._blackout = null;
              fc._blackoutStart = null;
            }
          });
          
          // Track object modifications for undo
          fc.on('object:modified', (e) => {
            const obj = e.target;
            
            if (obj._originalLeft !== undefined && obj._originalTop !== undefined) {
              // This was a move operation
              undoHistory.push({
                canvasIndex: fabricCanvases.indexOf(fc),
                type: 'move',
                object: obj,
                oldLeft: obj._originalLeft,
                oldTop: obj._originalTop,
                newLeft: obj.left,
                newTop: obj.top
              });
              
              // Clean up temp properties
              delete obj._originalLeft;
              delete obj._originalTop;
            }
            
            if (obj._originalState) {
              // This was a transform operation (resize, rotate, etc)
              const newState = {
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                angle: obj.angle,
                width: obj.width,
                height: obj.height
              };
              
              // Only add to history if something actually changed
              let hasChanged = false;
              for (const prop in newState) {
                if (newState[prop] !== obj._originalState[prop]) {
                  hasChanged = true;
                  break;
                }
              }
              
              if (hasChanged) {
                undoHistory.push({
                  canvasIndex: fabricCanvases.indexOf(fc),
                  type: 'modify',
                  object: obj,
                  oldState: obj._originalState,
                  newState: newState
                });
              }
              
              // Clean up temp properties
              delete obj._originalState;
            }
          });
        }
      }
      updateToolMode();

      // Add this line:
      if (currentTool === 'select') {
        initializeMultiSelect();
      }

      function enableMultiSelectOnAllCanvases() {
      if (currentTool === 'select') {
        fabricCanvases.forEach(fc => {
          // Make sure selection is enabled
          fc.selection = true;
          
          // Make sure all objects are selectable
          fc.getObjects().forEach(o => {
            o.selectable = true;
            o.evented = true;
          });
          
          // Update the canvas
          fc.renderAll();
        });
      }
    }

    // Modify the tool switching event listener
    // Find the existing tool switching code:
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
        updateToolMode();
        
        // Add this line:
        if (currentTool === 'select') {
          initializeMultiSelect();
        }
      });
    });

    // Replace it with this updated version:
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
        updateToolMode();
        
        // If switching to select tool, ensure multiple selection is enabled
        if (currentTool === 'select') {
          enableMultiSelectOnAllCanvases();
        }
      });
    });
    }

    function toggleReorderMode() {
      if (!pdfCanvases.length) {
        alert('Please load a PDF first.');
        return;
      }

      reorderingMode = !reorderingMode;
      reorderPagesBtn.textContent = reorderingMode ? 'Exit Reorder Mode' : 'Reorder Pages';
      reorderPagesBtn.style.background = reorderingMode ? 'var(--secondary)' : '';
      
      // Toggle reordering class on container
      pagesContainer.classList.toggle('reordering', reorderingMode);
      
      if (reorderingMode) {
        // Disable the default PDF drag and drop behavior while in reordering mode
        pagesContainer.removeEventListener('dragover', pagesContainerDragOver);
        pagesContainer.removeEventListener('dragleave', pagesContainerDragLeave);
        pagesContainer.removeEventListener('drop', pagesContainerDrop);
        
        // Store current tool to restore later
        previousTool = currentTool;
        
        // Temporarily disable other tools during reordering
        toolButtons.forEach(btn => btn.classList.remove('active'));
        currentTool = 'reordering';
        
        // Store the current order as the original order
        originalPageOrder = [];
        for (let i = 0; i < pdfCanvases.length; i++) {
          originalPageOrder.push(i);
        }
        
        // Add page numbers to each page
        const pageContainers = document.querySelectorAll('.page-container');
        pageContainers.forEach((container, index) => {
          // Set data attribute to track original index
          container.dataset.originalIndex = index;
          
          // Add page number indicator if it doesn't exist
          if (!container.querySelector('.page-order-indicator')) {
            const indicator = document.createElement('div');
            indicator.className = 'page-order-indicator';
            indicator.textContent = `Page ${index + 1}`;
            container.appendChild(indicator);
          } else {
            // Update existing indicator
            container.querySelector('.page-order-indicator').textContent = `Page ${index + 1}`;
          }
        });
        
        // Disable fabric canvas interactivity during reordering
        fabricCanvases.forEach(fc => {
          fc.selection = false;
          fc.isDrawingMode = false;
          fc.forEachObject(obj => {
            obj.selectable = false;
            obj.evented = false;
          });
          fc.renderAll();
        });
        
        // Initialize Sortable.js on the pages container
        sortablePages = new Sortable(pagesContainer, {
          animation: 150,
          handle: '.page-container', // This selects the entire container
          draggable: '.page-container',
          ghostClass: 'dragging',
          onEnd: updatePageOrder,
          delay: 100, // Small delay to improve drag detection
          delayOnTouchOnly: true, // Only delay for touch devices
          touchStartThreshold: 5, // Distance threshold before drag starts
        });
        
        // Show reorder controls
        const reorderControls = document.createElement('div');
        reorderControls.className = 'reorder-controls';
        reorderControls.id = 'reorder-controls';
        
        const applyReorderBtn = document.createElement('button');
        applyReorderBtn.textContent = 'Apply New Order';
        applyReorderBtn.addEventListener('click', applyPageReordering);
        
        const cancelReorderBtn = document.createElement('button');
        cancelReorderBtn.textContent = 'Cancel';
        cancelReorderBtn.className = 'secondary-btn';
        cancelReorderBtn.addEventListener('click', cancelReordering);
        
        reorderControls.appendChild(applyReorderBtn);
        reorderControls.appendChild(cancelReorderBtn);
        document.body.appendChild(reorderControls);
        reorderControls.style.display = 'flex';
        
        // Prevent default behavior to avoid the popup
        pagesContainer.addEventListener('dragover', preventDefaultDragEvent);
        pagesContainer.addEventListener('drop', preventDefaultDragEvent);
      } else {
        exitReorderMode();
      }
    }

    function exitReorderMode() {
      // Exit reorder mode
      if (document.getElementById('reorder-controls')) {
        document.getElementById('reorder-controls').remove();
      }
      
      // Remove page indicators
      document.querySelectorAll('.page-order-indicator').forEach(indicator => {
        indicator.remove();
      });
      
      // Destroy Sortable instance
      if (sortablePages) {
        sortablePages.destroy();
        sortablePages = null;
      }
      
      // Restore original drag-and-drop event listeners for PDF loading
      pagesContainer.removeEventListener('dragover', preventDefaultDragEvent);
      pagesContainer.removeEventListener('drop', preventDefaultDragEvent);
      
      pagesContainer.addEventListener('dragover', pagesContainerDragOver);
      pagesContainer.addEventListener('dragleave', pagesContainerDragLeave);
      pagesContainer.addEventListener('drop', pagesContainerDrop);
      
      // Restore previous tool
      currentTool = previousTool;
      
      // Reactivate the appropriate tool button
      toolButtons.forEach(btn => {
        if (btn.dataset.tool === currentTool) {
          btn.classList.add('active');
        }
      });
      
      // Update tool mode
      updateToolMode();
    }

    function cancelReordering() {
      // Restore the original page order
      restoreOriginalOrder();
      
      // Exit reorder mode
      reorderingMode = false;
      reorderPagesBtn.textContent = 'Reorder Pages';
      reorderPagesBtn.style.background = '';
      pagesContainer.classList.remove('reordering');
      exitReorderMode();
    }

    function restoreOriginalOrder() {
      if (originalPageOrder.length === 0) return;
      
      // Create temporary arrays with the original order
      const restoredFabricCanvases = [];
      const restoredPdfCanvases = [];
      
      // Populate the arrays in the original order
      for (let i = 0; i < originalPageOrder.length; i++) {
        const currentIndex = originalPageOrder.indexOf(i);
        restoredFabricCanvases[i] = fabricCanvases[currentIndex];
        restoredPdfCanvases[i] = pdfCanvases[currentIndex];
      }
      
      // Replace the current arrays
      fabricCanvases = restoredFabricCanvases;
      pdfCanvases = restoredPdfCanvases;
      
      // Rebuild the DOM
      rebuildPagesDOM();
    }

    // Function to update page numbers after drag
    function updatePageOrder() {
      // Update all page number indicators
      const pageContainers = document.querySelectorAll('.page-container');
      pageContainers.forEach((container, index) => {
        const indicator = container.querySelector('.page-order-indicator');
        if (indicator) {
          indicator.textContent = `Page ${index + 1}`;
        }
      });
    }

    // Function to apply the new page order
    function applyPageReordering() {
      // Get the new order of pages
      const pageContainers = Array.from(document.querySelectorAll('.page-container'));
      
      // Create temporary arrays to store the new order
      const reorderedFabricCanvases = [];
      const reorderedPdfCanvases = [];
      
      // For each container in the new order, get its original index
      pageContainers.forEach(container => {
        const originalIndex = parseInt(container.dataset.originalIndex);
        reorderedFabricCanvases.push(fabricCanvases[originalIndex]);
        reorderedPdfCanvases.push(pdfCanvases[originalIndex]);
      });
      
      // Replace the original arrays with the reordered ones
      fabricCanvases = reorderedFabricCanvases;
      pdfCanvases = reorderedPdfCanvases;
      
      // Exit reorder mode
      reorderingMode = false;
      reorderPagesBtn.textContent = 'Reorder Pages';
      reorderPagesBtn.style.background = '';
      pagesContainer.classList.remove('reordering');
      if (document.getElementById('reorder-controls')) {
        document.getElementById('reorder-controls').remove();
      }
      
      // Rebuild the DOM with the new order
      rebuildPagesDOM();

      // Preserve zoom level after reordering pages
      if (currentZoomIndex !== 3) { // If not at default 100%
        applyZoom(zoomLevels[currentZoomIndex]);
      }
    }

    // Function to rebuild the DOM with the current page order
    function rebuildPagesDOM() {
      // Save the scroll position
      const scrollPosition = window.scrollY;
      
      // Clear the container
      pagesContainer.innerHTML = '';
      
      // Add each page in the current order
      for (let i = 0; i < pdfCanvases.length; i++) {
        const pdfCanv = pdfCanvases[i];
        const fc = fabricCanvases[i];
        
        // Create a container for this page
        const wrapper = document.createElement('div');
        wrapper.className = 'page-container';
        wrapper.style.width = pdfCanv.width + 'px';
        wrapper.style.height = pdfCanv.height + 'px';
        
        // Add the PDF canvas
        wrapper.appendChild(pdfCanv);
        
        // Properly handle the fabric canvas
        wrapper.appendChild(fc.wrapperEl);
        
        // Add the complete page to the document
        pagesContainer.appendChild(wrapper);
        
        // Make sure fabric.js recalculates its position
        fc.setDimensions({
          width: pdfCanv.width,
          height: pdfCanv.height
        });
        fc.calcOffset();
        fc.requestRenderAll();
      }
      
      // Restore the scroll position
      window.scrollTo(0, scrollPosition);
    }

    // Simple function to prevent default drag events
    function preventDefaultDragEvent(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Store the previous tool to restore after reordering
    let previousTool = 'select';

    // Function to apply zoom to all pages
    function applyZoom(zoomFactor) {
      // Update zoom level display
      document.getElementById('zoom-level').textContent = Math.round(zoomFactor * 100) + '%';
      
      // Get all page containers
      const pageContainers = document.querySelectorAll('.page-container');
      
      pageContainers.forEach((container, index) => {
        const pdfCanvas = pdfCanvases[index];
        const fabricCanvas = fabricCanvases[index];
        
        if (!pdfCanvas || !fabricCanvas) return;
        
        // Store original dimensions if not already stored
        if (!pdfCanvas.originalWidth) {
          pdfCanvas.originalWidth = pdfCanvas.width;
          pdfCanvas.originalHeight = pdfCanvas.height;
        }
        
        // Calculate new dimensions
        const newWidth = Math.round(pdfCanvas.originalWidth * zoomFactor);
        const newHeight = Math.round(pdfCanvas.originalHeight * zoomFactor);
        
        // Update container dimensions
        container.style.width = newWidth + 'px';
        container.style.height = newHeight + 'px';
        
        // Update PDF canvas dimensions and scale content
        pdfCanvas.width = newWidth;
        pdfCanvas.height = newHeight;
        
        // We need to redraw the PDF at the new scale
        if (pdfCanvas.pdfPage) {
          const viewport = pdfCanvas.pdfPage.getViewport({ scale: 1.5 * zoomFactor });
          pdfCanvas.pdfPage.render({ 
            canvasContext: pdfCanvas.getContext('2d'), 
            viewport: viewport 
          });
        }
        
        // Update fabric canvas dimensions
        fabricCanvas.setDimensions({
          width: newWidth,
          height: newHeight
        });
        
        // Scale all objects on the fabric canvas
        const objects = fabricCanvas.getObjects();
        objects.forEach(obj => {
          // If we're storing original positions and sizes
          if (!obj.originalScaleX && zoomFactor !== 1.0) {
            obj.originalLeft = obj.left;
            obj.originalTop = obj.top;
            obj.originalScaleX = obj.scaleX;
            obj.originalScaleY = obj.scaleY;
            if (obj.fontSize) obj.originalFontSize = obj.fontSize;
          }
          
          if (zoomFactor === 1.0 && obj.originalScaleX) {
            // Reset to original values
            obj.set({
              left: obj.originalLeft,
              top: obj.originalTop,
              scaleX: obj.originalScaleX,
              scaleY: obj.originalScaleY
            });
            if (obj.originalFontSize) obj.set('fontSize', obj.originalFontSize);
          } else if (obj.originalScaleX) {
            // Scale based on original values and zoom factor
            obj.set({
              left: obj.originalLeft * zoomFactor,
              top: obj.originalTop * zoomFactor,
              scaleX: obj.originalScaleX * zoomFactor,
              scaleY: obj.originalScaleY * zoomFactor
            });
            if (obj.originalFontSize) obj.set('fontSize', obj.originalFontSize * zoomFactor);
          }
        });
        
        fabricCanvas.renderAll();
      });
    }

    // Add event listeners once DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Get zoom control elements
      const zoomInBtn = document.getElementById('zoom-in-btn');
      const zoomOutBtn = document.getElementById('zoom-out-btn');
      const zoomResetBtn = document.getElementById('zoom-reset-btn');
      
      // Add event listeners for zoom buttons
      if (zoomInBtn) {
        zoomInBtn.addEventListener('click', () => {
          if (currentZoomIndex < zoomLevels.length - 1) {
            currentZoomIndex++;
            applyZoom(zoomLevels[currentZoomIndex]);
          }
        });
      }
      
      if (zoomOutBtn) {
        zoomOutBtn.addEventListener('click', () => {
          if (currentZoomIndex > 0) {
            currentZoomIndex--;
            applyZoom(zoomLevels[currentZoomIndex]);
          }
        });
      }
      
      if (zoomResetBtn) {
        zoomResetBtn.addEventListener('click', () => {
          currentZoomIndex = 3; // Reset to 100%
          applyZoom(zoomLevels[currentZoomIndex]);
        });
      }
    });

    // Add keyboard shortcuts for zooming
    document.addEventListener('keydown', (e) => {
      // Only process if we're not in a text field
      if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        if (e.ctrlKey && (e.key === '=' || e.key === '+')) {
          // Ctrl + = or Ctrl + + for zoom in
          e.preventDefault();
          if (currentZoomIndex < zoomLevels.length - 1) {
            currentZoomIndex++;
            applyZoom(zoomLevels[currentZoomIndex]);
          }
        } else if (e.ctrlKey && e.key === '-') {
          // Ctrl + - for zoom out
          e.preventDefault();
          if (currentZoomIndex > 0) {
            currentZoomIndex--;
            applyZoom(zoomLevels[currentZoomIndex]);
          }
        } else if (e.ctrlKey && e.key === '0') {
          // Ctrl + 0 for reset zoom
          e.preventDefault();
          currentZoomIndex = 3; // Reset to 100%
          applyZoom(zoomLevels[currentZoomIndex]);
        }
      }
    });

    // Add mouse wheel zoom
    document.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        
        // Zoom in or out based on wheel direction
        if (e.deltaY < 0 && currentZoomIndex < zoomLevels.length - 1) {
          // Wheel up - zoom in
          currentZoomIndex++;
          applyZoom(zoomLevels[currentZoomIndex]);
        } else if (e.deltaY > 0 && currentZoomIndex > 0) {
          // Wheel down - zoom out
          currentZoomIndex--;
          applyZoom(zoomLevels[currentZoomIndex]);
        }
      }
    }, { passive: false });
  </script>
</body>
</html>