<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Annotation Tool - The DollarWeb</title>
      <style>
    /* Inter and Montserrat Fonts */
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 400;
      src: url('/fonts/inter-regular.woff2') format('woff2');
    }
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 500;
      src: url('/fonts/inter-medium.woff2') format('woff2');
    }
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 600;
      src: url('/fonts/inter-semibold.woff2') format('woff2');
    }

    @font-face {
      font-family: 'Montserrat';
      font-style: normal;
      src: url('/fonts/Montserrat-VariableFont_wght.ttf') format('truetype-variations');
      font-weight: 100 900; /* This tells the browser this file contains all weights */
      font-display: swap;
    }

    @font-face {
      font-family: 'Montserrat';
      font-style: italic;
      src: url('/fonts/Montserrat-Italic-VariableFont_wght.ttf') format('truetype-variations');
      font-weight: 100 900;
      font-display: swap;
    }

    :root {
      --primary: #00a896;
      --secondary: #f8b500;
      --accent: #ff6b6b;
      --light: #f8f9fa;
      --dark: #05668d;
      --text: #333;
      --bg: #f5f9f8;
      --highlight: rgba(255, 241, 118, 0.4); /* Default highlight color */
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg);
      color: var(--text);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' opacity='0.03' viewBox='0 0 120 120'%3E%3Cpath d='M20,60 C20,60 35,30 60,30 C85,30 100,60 100,60 C100,60 85,90 60,90 C35,90 20,60 20,60 Z' fill='%2300a896'/%3E%3C/svg%3E");
      background-size: 120px;
      padding-top: 70px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      text-align: center;
      padding: 40px 0 0px;
    }
    
    h1 {
      font-family: 'Montserrat', sans-serif;
      font-size: 3.2rem;
      color: var(--primary);
      margin-bottom: 1.2rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      margin-top: 80px;
    }
    
    p.tagline {
      font-size: 1.3rem;
      color: var(--dark);
      max-width: 700px;
      margin: 0 auto 2rem;
      line-height: 1.6;
      font-weight: 300;
    }

    /* Navigation Bar Styles */
    .main-nav {
      background: white;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.08);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 2000;
    }

    .nav-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
    }

    .nav-logo {
      display: flex;
      align-items: center;
      text-decoration: none;
      color: var(--primary);
      font-weight: 600;
      font-size: 1.5rem;
      transition: all 0.2s;
    }

    .nav-logo:hover {
      transform: translateY(-2px);
    }

    .nav-logo svg {
      margin-right: 10px;
    }

    .nav-links {
      display: flex;
      align-items: center;
      gap: 30px;
    }

    .nav-links a {
      color: var(--dark);
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
    }

    .nav-links a:hover {
      color: var(--primary);
    }

    .login-btn {
      background: var(--primary);
      color: white !important;
      padding: 10px 20px;
      border-radius: 8px;
      transition: all 0.2s !important;
    }

    .login-btn:hover {
      background: var(--dark);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    /* Footer Styles */
    .site-footer {
      background: var(--dark);
      padding: 40px 0 50px;
      margin-top: 80px;
      position: relative;
      color: white;
    }

    .footer-wave {
      position: absolute;
      top: -120px;
      left: 0;
      right: 0;
      height: 120px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 120' width='1200' height='120' opacity='0.1'%3E%3Cpath d='M0,100 C200,20 400,60 600,80 C800,100 1000,40 1200,120 L1200,120 L0,120 Z' fill='%23ffffff'/%3E%3C/svg%3E");
      background-repeat: repeat-x;
      background-position: bottom;
    }

    .footer-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .footer-logo {
      display: flex;
      align-items: center;
      margin-bottom: 40px;
      color: var(--secondary);
    }

    .footer-logo svg {
      width: 48px;
      height: 48px;
      margin-right: 16px;
    }

    .footer-logo span {
      font-weight: 600;
      font-size: 2.4rem;
    }

    .footer-links {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 40px;
    }

    .footer-links a {
      color: var(--light);
      text-decoration: none;
      margin: 0 30px;
      font-size: 1.8rem;
      transition: color 0.2s;
    }

    .footer-links a:hover {
      color: var(--secondary);
    }

    .footer-social {
      display: flex;
      gap: 30px;
      margin-bottom: 40px;
    }

    .footer-social a {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      transition: all 0.2s;
    }

    .footer-social a svg {
      width: 40px;
      height: 40px;
    }

    .footer-social a:hover {
      background: var(--secondary);
      color: var(--dark);
      transform: translateY(-3px);
    }

    .copyright {
      font-size: 1.8rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .copyright-message {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .secondary-text {
      color: var(--secondary);
    }
    
    .tertiary-text {
      color: var(--dark);
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .nav-links {
        gap: 15px;
      }
      
      .nav-logo span {
        font-size: 1.2rem;
      }
      
      .footer-links {
        flex-direction: column;
        gap: 20px;
      }
      
      .footer-links a {
        margin: 10px 0;
      }
    }

    @media (max-width: 576px) {
      .nav-links a:not(.login-btn) {
        display: none;
      }
    }

    /* PDF Annotation Specific Styles */
    #toolbar {
      position: fixed;
      top: 70px;
      left: 0;
      right: 0;
      background: white;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      z-index: 1000;
      justify-content: center;
    }
    
    #toolbar * { 
      margin: 4px; 
    }
    
    button {
      padding: 8px 12px;
      border: none;
      background: var(--primary);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    button:hover {
      background: var(--dark);
      transform: translateY(-2px);
    }
    
    button.active {
      background: var(--dark);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    #file-list-container {
      margin-top: 150px;
      padding: 20px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.06);
      margin-bottom: 20px;
      display: none;
      text-align: center;
    }
    
    #file-list {
      list-style: none;
      padding: 0;
      margin: 16px auto;
      max-width: 600px;
    }
    
    #file-list li {
      padding: 12px 16px;
      margin: 8px 0;
      background: var(--bg);
      border-radius: 8px;
      border: 1px solid #ddd;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
    }
    
    #file-list li:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.05);
    }
    
    .file-list-item-content {
      flex-grow: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .remove-file-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 4px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .remove-file-btn:hover {
      background: #ff5252;
      transform: scale(1.1);
    }
    
    .file-list-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 16px;
    }
    
    #load-btn {
      background: var(--secondary);
    }
    
    #load-btn:hover {
      background: #e9a800;
    }
    
    .secondary-btn {
      background: #e0e0e0;
      color: var(--text);
    }
    
    .secondary-btn:hover {
      background: #d0d0d0;
    }
    
    #pages-container {
      margin-top: 70px;
      padding: 40px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 300px;
      border: 2px dashed #bbb;
      border-radius: 16px;
      transition: all 0.3s;
    }
    
    /* Page selection styles */
    .page-selection-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
      display: none;
    }
    
    /* Make the page checkbox container larger and more visible */
    .page-checkbox-container {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 8px;
      z-index: 102; /* Make sure it's above other elements */
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      border: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Style the checkbox itself to be larger */
    .page-checkbox {
      width: 24px;
      height: 24px;
      cursor: pointer;
      accent-color: var(--primary); /* Color the checkbox with the primary theme color */
    }

    /* Add hover effect */
    .page-checkbox-container:hover {
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
      transform: scale(1.05);
      transition: all 0.2s;
    }

    /* Add a label next to the checkbox for better clarity */
    .page-checkbox-container::after {
      content: "Select";
      font-size: 0.9rem;
      margin-left: 6px;
      color: var(--dark);
      font-weight: 500;
    }

    /* Add these styles to show selected state even when not in selection mode */
    .page-container.selected {
      border: 3px solid var(--primary);
      box-shadow: 0 5px 15px rgba(0, 168, 150, 0.2);
    }

    .page-selected-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 168, 150, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: 500;
      z-index: 5;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 0.9rem;
      pointer-events: none; /* Don't interfere with interaction */
      display: flex;
      align-items: center;
    }

    .page-selected-indicator::before {
      content: "✓";
      margin-right: 5px;
      font-weight: bold;
    }

    
    .page-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.9rem;
      color: var(--dark);
      z-index: 2;
    }
    
    #pages-container.dragover {
      background: rgba(0, 168, 150, 0.05);
      border-color: var(--primary);
    }
    
    .page-container {
      position: relative;
      margin: 24px 0;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    .os-links a {
      color: var(--primary); text-decoration: none; font-size: 0.9rem;
    }
    .os-links a:hover { text-decoration: underline; }
    
    .pdf-canvas, .annotation-canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .pdf-canvas { z-index: 0; }
    .annotation-canvas { z-index: 1; }
    
    /* Confirmation Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal-container {
      background-color: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
      width: 90%;
      max-width: 500px;
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }
    
    .modal-overlay.active .modal-container {
      transform: translateY(0);
    }
    
    .modal-header {
      margin-bottom: 20px;
      text-align: center;
    }
    
    .modal-header h3 {
      font-size: 1.5rem;
      color: var(--dark);
      margin: 0;
    }
    
    .modal-body {
      margin-bottom: 25px;
      text-align: center;
      font-size: 1.1rem;
      color: var(--text);
    }
    
    .modal-footer {
      display: flex;
      justify-content: center;
      gap: 15px;
    }
    
    .modal-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .modal-btn-cancel {
      background-color: #e9ecef;
      color: var(--text);
    }
    
    .modal-btn-cancel:hover {
      background-color: #dee2e6;
    }
    
    .modal-btn-confirm {
      background-color: #f44336;
      color: white;
    }
    
    .modal-btn-confirm:hover {
      background-color: #e53935;
      transform: translateY(-2px);
    }
    
    label {
      display: flex;
      align-items: center;
      font-weight: 500;
    }

    label[for="text-input"], 
    label:has(#text-input) {
      font-weight: 500;
      display: flex;
      align-items: center;
      margin-right: 15px;
    }
    
    input[type="text"], input[type="number"] {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    
    input[type="file"] {
      padding: 8px;
    }
    
    input[type="range"] {
      width: 100px;
    }
    
    #text-input {
      width: 150px;
    }
    
    #font-size {
      width: 60px;
    }
    
    #undo-btn {
      background: var(--accent);
    }
    
    #clear-btn {
      background: #f44336;
    }
    
    #save-btn {
      background: var(--dark);
    }

    #text-input {
      width: 200px;  /* Make it wider */
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-right: 10px;
    }

    #text-input:focus {
      border-color: var(--primary);
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 168, 150, 0.2);
    }

    /* Reordering mode styles */
    #pages-container.reordering .page-container {
      cursor: grab;
      transition: all 0.2s;
      border: 2px dashed transparent;
      position: relative;
      margin-bottom: 40px; /* Add more space between pages in reordering mode */
    }

    #pages-container.reordering .page-container:hover {
      border-color: var(--primary);
      transform: translateY(-5px);
      box-shadow: 0 15px 25px rgba(0, 0, 0, 0.15);
    }

    #pages-container.reordering .page-container.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }

    /* Page number indicator */
    .page-order-indicator {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 168, 150, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: bold;
      z-index: 10;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 0.9rem;
    }

    /* Reorder controls */
    .reorder-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
    }

    /* Style for the reorder button in the toolbar */
    #reorder-pages-btn {
      background: var(--primary);
    }

    #reorder-pages-btn:hover {
      background: var(--dark);
    }

    #reorder-pages-btn.active {
      background: var(--secondary);
    }

    /* Invisible overlay to make entire page draggable */
    #pages-container.reordering .page-container::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 100; /* Place above canvases */
      cursor: grab;
      background: transparent;
      pointer-events: auto; /* Allow interaction */
    }

    #pages-container.reordering .page-container.dragging::after {
      cursor: grabbing;
    }

    /* Update the page-order-indicator to appear above the overlay */
    .page-order-indicator {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 168, 150, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: bold;
      z-index: 101; /* Above the ::after overlay */
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 0.9rem;
    }

  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="main-nav">
    <div class="container nav-container">
      <a href="index.html" class="nav-logo">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
          <polyline points="9 22 9 12 15 12 15 22"></polyline>
        </svg>
        <span class="tertiary-text">The&nbsp;</span>Dollar<span class="secondary-text">Web</span>
      </a>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <a href="index.html#tools">Tools</a>
        <a href="index.html#about">About</a>
        <a href="login.html" class="login-btn">Login</a>
      </div>
    </div>
  </nav>

  <div class="container">
    <header>
      <h1>PDF Annotation Tool</h1>
      <p class="tagline">Combine or split PDFs. Add notes, highlights, and drawings to your PDF documents. Edit multiple PDFs at once and save your changes.</p>
      <div class="os-links">
        <a href="/licenses.html">Open-source acknowledgements</a>
      </div>
    </header>
    
    <div id="toolbar">
      <input type="file" id="file-input" accept="application/pdf" multiple>
      <button data-tool="select" class="active">Select</button>
      <button data-tool="draw">Draw</button>
      <button data-tool="line">Line</button>
      <button data-tool="highlight">Highlight</button>
      <button data-tool="text">Text</button>
      <label>Color: <input type="color" id="color-picker" value="#05668d"></label>
      <label>Size: <input type="range" id="size-slider" min="1" max="20" value="2"></label>
      <label>Font Size: <input type="number" id="font-size" min="10" max="72" value="24"></label>
      <label>Document Title: <input type="text" id="text-input" placeholder="Document title"></label>
      <button id="undo-btn">Undo</button>
      <button id="clear-btn">Clear</button>
      <button id="toggle-selection-btn">Select Pages</button>
      <button id="reorder-pages-btn">Reorder Pages</button>
      <button id="save-btn">Download</button>
    </div>
    
    <div class="page-selection-controls" id="page-selection-controls">
      <button id="select-all-btn">Select All</button>
      <button id="deselect-all-btn">Deselect All</button>
      <span id="selected-count">0 pages selected</span>
    </div>

    <div id="file-list-container">
      <strong>Reorder your PDFs:</strong>
      <ul id="file-list"></ul>
      <div class="file-list-buttons">
        <button id="load-btn">Load PDFs</button>
        <button id="clear-files-btn" class="secondary-btn">Clear All Files</button>
      </div>
    </div>

    <div id="pages-container">
      <p style="color:#666; margin-top:100px; text-align:center; font-size:1.2rem;">
        Drag & drop PDFs here, or use the file input above.<br>
        <br>
        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="12" y1="18" x2="12" y2="12"></line>
          <line x1="9" y1="15" x2="15" y2="15"></line>
        </svg>
      </p>
    </div>
  </div>
  
  <!-- Footer -->
  <footer class="site-footer">
    <div class="footer-wave"></div>
    <div class="footer-content">
      <div class="footer-logo">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
          <polyline points="9 22 9 12 15 12 15 22"></polyline>
        </svg>
        <span>The DollarWeb</span>
      </div>
      <div class="footer-links">
        <a href="index.html">Home</a>
        <a href="#">About</a>
        <a href="#">Contact</a>
        <a href="#">Privacy Policy</a>
        <a href="#">Terms of Service</a>
      </div>
      <div class="footer-social">
        <a href="#" aria-label="Twitter">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
          </svg>
        </a>
        <a href="#" aria-label="Facebook">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>
          </svg>
        </a>
        <a href="#" aria-label="Instagram">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
            <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
            <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
          </svg>
        </a>
      </div>
      <p class="copyright">&copy; 2025 The DollarWeb</p>
      <p class="copyright-message">Professional tools that won't break the bank</p>
    </div>
  </footer>

  <!-- Confirmation Modals -->
  <div class="modal-overlay" id="confirmation-modal">
    <div class="modal-container">
      <div class="modal-header">
        <h3>Clear All Annotations?</h3>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to clear all annotations? This action cannot be undone.</p>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="cancel-clear">Cancel</button>
        <button class="modal-btn modal-btn-confirm" id="confirm-clear">Clear All</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="clear-files-modal">
    <div class="modal-container">
      <div class="modal-header">
        <h3>Clear All Files?</h3>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to remove all PDF files from the list? This will not affect any loaded PDFs that you're currently annotating.</p>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="cancel-clear-files">Cancel</button>
        <button class="modal-btn modal-btn-confirm" id="confirm-clear-files">Clear All Files</button>
      </div>
    </div>
  </div>
  
  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>

  <script>
    // PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    // DOM refs
    const fileInput          = document.getElementById('file-input');
    const fileListCont       = document.getElementById('file-list-container');
    const fileListEl         = document.getElementById('file-list');
    const loadBtn            = document.getElementById('load-btn');
    const clearFilesBtn      = document.getElementById('clear-files-btn');
    const pagesContainer     = document.getElementById('pages-container');
    const toolButtons        = document.querySelectorAll('#toolbar button[data-tool]');
    const colorPicker        = document.getElementById('color-picker');
    const sizeSlider         = document.getElementById('size-slider');
    const fontSizeInput      = document.getElementById('font-size');
    const textInput          = document.getElementById('text-input');
    const undoBtn            = document.getElementById('undo-btn');
    const clearBtn           = document.getElementById('clear-btn');
    const saveBtn            = document.getElementById('save-btn');
    const toggleSelectionBtn = document.getElementById('toggle-selection-btn');
    const selectAllBtn       = document.getElementById('select-all-btn');
    const deselectAllBtn     = document.getElementById('deselect-all-btn');
    const selectedCountEl    = document.getElementById('selected-count');
    const pageSelectionCtrls = document.getElementById('page-selection-controls');

    // state
    let currentTool       = 'select';
    let fabricCanvases    = [];
    let pdfCanvases       = [];
    let lastFocusedCanvas = null;
    let fileBlobs         = [];
    let selectionMode     = false;
    let undoHistory       = []; // Track actions for undo functionality
    let originalPageOrder = []; // To track original page order during reordering

    // init Sortable on file list
    Sortable.create(fileListEl, { animation: 150 });

    // Add the reorder button initialization here
    const reorderPagesBtn = document.getElementById('reorder-pages-btn');
    let reorderingMode = false;
    let sortablePages = null;

    // Reorder mode toggle functionality
    reorderPagesBtn.addEventListener('click', toggleReorderMode);

    // tool switching
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
        updateToolMode();
      });
    });

    function updateToolMode() {
      fabricCanvases.forEach(fc => {
        // Set drawing mode only if current tool is draw
        fc.isDrawingMode = (currentTool === 'draw');
        
        // Allow selection only in select mode
        fc.selection = (currentTool === 'select');
        
        // Change cursor based on tool
        if (currentTool === 'select') {
          fc.defaultCursor = 'default';
        } else if (currentTool === 'highlight') {
          fc.defaultCursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23000000\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3E%3Cpath d=\'M12 20h9\'%3E%3C/path%3E%3Cpath d=\'M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z\'%3E%3C/path%3E%3C/svg%3E") 1 17, auto';
        } else {
          fc.defaultCursor = 'crosshair';
        }
        
        // Update brush properties
        fc.freeDrawingBrush.width = +sizeSlider.value;
        fc.freeDrawingBrush.color = colorPicker.value;
        
        // Update objects selectability
        fc.getObjects().forEach(o => {
          o.selectable = (currentTool === 'select');
          o.evented = true; // Make sure objects respond to events
        });
        
        // Important for multi-select: Enable group selection
        if (currentTool === 'select') {
          fc.preserveObjectStacking = true; // Maintains z-index during selection
          fc.uniScaleTransform = false; // Allows non-uniform scaling
        }
        
        fc.renderAll();
      });
    }

    function initializeMultiSelect() {
      if (currentTool === 'select') {
        fabricCanvases.forEach(fc => {
          // Ensure selection mode is enabled
          fc.selection = true;
          
          // Make sure objects can be selected
          fc.getObjects().forEach(obj => {
            obj.selectable = true;
            obj.evented = true;
          });
          
          // Enable multiple selection with selection boxes
          fc.selectionFullyContained = false; // Select objects even if partly in selection
          
          // Ensure canvas knows when it's active
          fc.on('mouse:down', function() {
            lastFocusedCanvas = fc;
          });
          
          fc.renderAll();
        });
      }
    }

    // Undo / Clear
    undoBtn.addEventListener('click', () => {
      const fc = lastFocusedCanvas || fabricCanvases.slice(-1)[0];
      if (!fc) return;
      
      // Check if there's an action in the undo history for this canvas
      const canvasIndex = fabricCanvases.indexOf(fc);
      const canvasHistory = undoHistory.filter(entry => entry.canvasIndex === canvasIndex);
      
      if (canvasHistory.length > 0) {
        // Get the most recent action for this canvas
        const lastAction = canvasHistory[canvasHistory.length - 1];
        
        // Remove this action from history
        undoHistory = undoHistory.filter(entry => entry !== lastAction);
        
        // Handle different types of actions
        if (lastAction.type === 'add') {
          // If object was added, remove it
          fc.remove(lastAction.object);
        } else if (lastAction.type === 'move') {
          // If object was moved, restore its previous position
          lastAction.object.set({
            left: lastAction.oldLeft,
            top: lastAction.oldTop
          });
          lastAction.object.setCoords();
          fc.renderAll();
        } else if (lastAction.type === 'modify') {
          // If object was modified (resized, rotated, etc.), restore its previous state
          Object.keys(lastAction.oldState).forEach(prop => {
            lastAction.object.set(prop, lastAction.oldState[prop]);
          });
          lastAction.object.setCoords();
          fc.renderAll();
        }
      } else {
        // Fall back to removing the last object if no history
        const objs = fc.getObjects();
        if (objs.length) fc.remove(objs.pop());
      }
    });
    
    // Clear button - show confirmation modal
    const confirmationModal = document.getElementById('confirmation-modal');
    const cancelClearBtn = document.getElementById('cancel-clear');
    const confirmClearBtn = document.getElementById('confirm-clear');
    
    clearBtn.addEventListener('click', () => {
      // Show the confirmation modal
      confirmationModal.classList.add('active');
    });
    
    // Cancel button in modal
    cancelClearBtn.addEventListener('click', () => {
      confirmationModal.classList.remove('active');
    });
    
    // Confirm button in modal
    confirmClearBtn.addEventListener('click', () => {
      // Hide the modal
      confirmationModal.classList.remove('active');
      
      // Actually clear the annotations
      fabricCanvases.forEach(fc => {
        fc.clear();
        // Clear undo history for this canvas
        const canvasIndex = fabricCanvases.indexOf(fc);
        undoHistory = undoHistory.filter(entry => entry.canvasIndex !== canvasIndex);
      });
    });
    
    // Close modal if clicked outside
    confirmationModal.addEventListener('click', (e) => {
      if (e.target === confirmationModal) {
        confirmationModal.classList.remove('active');
      }
    });
    
    // Clear files button - show confirmation modal
    const clearFilesModal = document.getElementById('clear-files-modal');
    const cancelClearFilesBtn = document.getElementById('cancel-clear-files');
    const confirmClearFilesBtn = document.getElementById('confirm-clear-files');
    
    clearFilesBtn.addEventListener('click', () => {
      // Show the confirmation modal
      clearFilesModal.classList.add('active');
    });
    
    // Cancel button in modal
    cancelClearFilesBtn.addEventListener('click', () => {
      clearFilesModal.classList.remove('active');
    });
    
    // Confirm button in modal
    confirmClearFilesBtn.addEventListener('click', () => {
      // Hide the modal
      clearFilesModal.classList.remove('active');
      
      // Clear all files
      fileBlobs = [];
      setupFileList();
    });
    
    // Close modal if clicked outside
    clearFilesModal.addEventListener('click', (e) => {
      if (e.target === clearFilesModal) {
        clearFilesModal.classList.remove('active');
      }
    });
    
    // Add keyboard event listeners for delete/backspace
    document.addEventListener('keydown', (e) => {
      // Check if Escape key was pressed (for modals)
      if (e.key === 'Escape') {
        if (confirmationModal.classList.contains('active')) {
          confirmationModal.classList.remove('active');
        }
        if (clearFilesModal.classList.contains('active')) {
          clearFilesModal.classList.remove('active');
        }
        return;
      }
      
      // Check if Delete or Backspace was pressed
      if (e.key === 'Delete' || e.key === 'Backspace') {
        // Only process if we're not in a text field
        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
          // Find the canvas that has the active selection
          const activeCanvas = fabricCanvases.find(fc => {
            return fc.getActiveObject() !== null;
          });
          
          if (activeCanvas) {
            const activeObj = activeCanvas.getActiveObject();
            if (activeObj) {
              // For multiple object selection
              if (activeObj.type === 'activeSelection') {
                // Get all objects in the selection
                const objectsToRemove = activeObj.getObjects();
                
                // Store each object in the undo history before removing
                objectsToRemove.forEach(obj => {
                  undoHistory.push({
                    canvasIndex: fabricCanvases.indexOf(activeCanvas),
                    type: 'add',
                    object: obj
                  });
                });
                
                // Discarding the group selection first
                activeCanvas.discardActiveObject();
                
                // Then remove each object individually
                objectsToRemove.forEach(obj => {
                  activeCanvas.remove(obj);
                });
                
                // Update the canvas
                activeCanvas.requestRenderAll();
              } else {
                // Single object deletion (existing functionality)
                undoHistory.push({
                  canvasIndex: fabricCanvases.indexOf(activeCanvas),
                  type: 'add',
                  object: activeObj
                });
                
                // Remove the object
                activeCanvas.remove(activeObj);
              }
              
              e.preventDefault(); // Prevent browser back navigation on backspace
            }
          }
        }
      }
    });

    // Save PDF with selected pages
    saveBtn.addEventListener('click', async () => {
      const { jsPDF } = window.jspdf;
      if (!pdfCanvases.length) return;
      
      // Get selected pages (if selection mode is active)
      const selectedPages = [];
      const checkboxes = document.querySelectorAll('.page-checkbox:checked');
      
      // If we have checkboxes and some are checked, use selection
      if (checkboxes.length > 0) {
        checkboxes.forEach(cb => {
          selectedPages.push(parseInt(cb.dataset.pageIndex));
        });
      } else {
        // Otherwise include all pages
        for (let i = 0; i < pdfCanvases.length; i++) {
          selectedPages.push(i);
        }
      }
      
      if (selectedPages.length === 0) {
        alert('Please select at least one page to save.');
        return;
      }
      
      // Get the document title from the text input
      let fileName = document.getElementById('text-input').value.trim();
      
      // If no title is provided, use a default
      if (fileName === '') {
        fileName = 'annotated.pdf';
      } else {
        // Ensure the filename ends with .pdf
        if (!fileName.toLowerCase().endsWith('.pdf')) {
          fileName += '.pdf';
        }
      }
      
      // start with first selected page's size/orientation
      const firstIdx = selectedPages[0];
      const first = pdfCanvases[firstIdx];
      const orient = first.width > first.height ? 'l' : 'p';
      const doc = new jsPDF({ unit:'px', format:[first.width,first.height], orientation:orient });
      
      // First page is already added by jsPDF constructor
      let currentPage = 1;
      
      for (let i = 0; i < selectedPages.length; i++) {
        const pageIdx = selectedPages[i];
        const pdfC = pdfCanvases[pageIdx];
        const fc = fabricCanvases[pageIdx];
        
        // Add a new page for all pages after the first one
        if (i > 0) {
          const o = pdfC.width > pdfC.height ? 'l' : 'p';
          doc.addPage([pdfC.width, pdfC.height], o);
          currentPage++;
        }
        
        // Set active page and render content
        doc.setPage(currentPage);
        
        // Composite PDF content and annotations
        const tmp = document.createElement('canvas');
        tmp.width = pdfC.width; 
        tmp.height = pdfC.height;
        const ctx = tmp.getContext('2d');
        ctx.drawImage(pdfC, 0, 0);
        ctx.drawImage(fc.lowerCanvasEl, 0, 0);
        
        // Add the combined image to the PDF
        doc.addImage(tmp.toDataURL('image/png'), 'PNG', 0, 0, pdfC.width, pdfC.height);
      }
      
      // Save the PDF with the title from the text input
      doc.save(fileName);
    });

    // brush settings updates
    colorPicker.addEventListener('change', updateToolMode);
    sizeSlider.addEventListener('input', updateToolMode);
    
    // Update the toggleSelectionBtn click handler to maintain visual selection state
    toggleSelectionBtn.addEventListener('click', () => {
      selectionMode = !selectionMode;
      toggleSelectionBtn.textContent = selectionMode ? 'Exit Selection Mode' : 'Select Pages';
      toggleSelectionBtn.style.background = selectionMode ? 'var(--secondary)' : '';
      pageSelectionCtrls.style.display = selectionMode ? 'flex' : 'none';
      
      // Show/hide checkboxes for all pages
      const pageContainers = document.querySelectorAll('.page-container');
      pageContainers.forEach((container, index) => {
        let checkbox = container.querySelector('.page-checkbox-container');
        
        if (selectionMode) {
          // Create checkbox if it doesn't exist
          if (!checkbox) {
            checkbox = document.createElement('div');
            checkbox.className = 'page-checkbox-container';
            
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.className = 'page-checkbox';
            cb.id = `page-checkbox-${index}`;
            cb.dataset.pageIndex = index;
            cb.checked = container.classList.contains('selected') || true; // Default to selected or use previous state
            
            // Update the visual indicator whenever checkbox changes
            cb.addEventListener('change', (e) => {
              updateSelectedCount();
              
              // Update the container's selected class
              if (e.target.checked) {
                container.classList.add('selected');
              } else {
                container.classList.remove('selected');
                
                // Remove visual indicator if present
                const indicator = container.querySelector('.page-selected-indicator');
                if (indicator) {
                  indicator.remove();
                }
              }
            });
            
            // Add label for better accessibility
            const label = document.createElement('label');
            label.htmlFor = `page-checkbox-${index}`;
            label.className = 'page-checkbox-label';
            label.appendChild(cb);
            
            checkbox.appendChild(label);
            container.appendChild(checkbox);
            
            // Add animation to draw attention
            checkbox.style.opacity = '0';
            checkbox.style.transform = 'scale(0.8)';
            checkbox.style.transition = 'all 0.3s ease';
            
            // Force reflow to make the animation work
            void checkbox.offsetWidth;
            
            // Animate in
            checkbox.style.opacity = '1';
            checkbox.style.transform = 'scale(1)';
            
            // Add page number indicator
            const pageInfo = document.createElement('div');
            pageInfo.className = 'page-info';
            pageInfo.textContent = `Page ${index + 1}`;
            container.appendChild(pageInfo);
            
            // Mark as selected initially (since checkbox is checked by default)
            container.classList.add('selected');
          } else {
            // Show existing checkbox
            checkbox.style.display = 'flex';
            
            // Update page info
            const pageInfo = container.querySelector('.page-info');
            if (pageInfo) pageInfo.style.display = 'block';
          }
        } else if (checkbox) {
          // Hide checkbox when not in selection mode
          checkbox.style.display = 'none';
          
          // Hide page info
          const pageInfo = container.querySelector('.page-info');
          if (pageInfo) pageInfo.style.display = 'none';
          
          // Check if this page is selected
          const cb = checkbox.querySelector('.page-checkbox');
          if (cb && cb.checked) {
            // Keep the container's selected class
            container.classList.add('selected');
            
            // Add a visual indicator that this page is selected
            if (!container.querySelector('.page-selected-indicator')) {
              const indicator = document.createElement('div');
              indicator.className = 'page-selected-indicator';
              indicator.textContent = 'Selected';
              container.appendChild(indicator);
            }
          } else {
            // Remove selected class and indicator
            container.classList.remove('selected');
            const indicator = container.querySelector('.page-selected-indicator');
            if (indicator) {
              indicator.remove();
            }
          }
        }
      });
      
      updateSelectedCount();
    });
    
    // Select/Deselect All
    selectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = true;
        
        // Update visual state
        const container = cb.closest('.page-container');
        if (container) {
          container.classList.add('selected');
        }
      });
      updateSelectedCount();
    });
    
    deselectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = false;
        
        // Update visual state
        const container = cb.closest('.page-container');
        if (container) {
          container.classList.remove('selected');
          
          // Remove any selection indicators
          const indicator = container.querySelector('.page-selected-indicator');
          if (indicator) {
            indicator.remove();
          }
        }
      });
      updateSelectedCount();
    });
    
    // Update the selected count
    function updateSelectedCount() {
      const total = document.querySelectorAll('.page-checkbox').length;
      const selected = document.querySelectorAll('.page-checkbox:checked').length;
      selectedCountEl.textContent = `${selected} of ${total} pages selected`;
    }

    // handle file input (multiple)
    fileInput.addEventListener('change', e => {
      const newFiles = Array.from(e.target.files).filter(f => f.type === 'application/pdf');
      if (newFiles.length > 0) {
        // Add new files to existing files array
        fileBlobs = [...fileBlobs, ...newFiles];
        setupFileList();
      }
    });

    // drag & drop to file list
    // Define named event handler functions
    const pagesContainerDragOver = function(e) {
      e.preventDefault();
      pagesContainer.classList.add('dragover');
    };

    const pagesContainerDragLeave = function() {
      pagesContainer.classList.remove('dragover');
    };

    const pagesContainerDrop = function(e) {
      e.preventDefault();
      pagesContainer.classList.remove('dragover');
      const dropped = Array.from(e.dataTransfer.files)
                          .filter(f => f.type === 'application/pdf');
      if (!dropped.length) {
        alert('Please drop PDF files only.');
        return;
      }
      
      // Add new files to existing files array instead of replacing
      fileBlobs = [...fileBlobs, ...dropped];
      setupFileList();
    };

    // Add event listeners using the named functions
    pagesContainer.addEventListener('dragover', pagesContainerDragOver);
    pagesContainer.addEventListener('dragleave', pagesContainerDragLeave);
    pagesContainer.addEventListener('drop', pagesContainerDrop);

    // populate & show the file-list
    function setupFileList() {
      fileListEl.innerHTML = '';
      fileBlobs.forEach((f, i) => {
        const li = document.createElement('li');
        
        // Create wrapper for file name that can be truncated
        const fileNameWrapper = document.createElement('div');
        fileNameWrapper.className = 'file-list-item-content';
        fileNameWrapper.textContent = f.name;
        li.appendChild(fileNameWrapper);
        
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-file-btn';
        removeBtn.innerHTML = '×'; // × character
        removeBtn.title = 'Remove this PDF';
        removeBtn.dataset.index = i;
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent triggering sortable
          const index = parseInt(e.target.dataset.index);
          removePdfFile(index);
        });
        li.appendChild(removeBtn);
        
        li.dataset.index = i;
        fileListEl.appendChild(li);
      });
      
      // Show the file list container if we have files
      if (fileBlobs.length > 0) {
        fileListCont.style.display = 'block';
        pagesContainer.innerHTML = '<p style="color:#666;margin-top:100px;text-align:center;font-size:1.2rem;">Drag & drop more PDFs here, or Reorder above and click Load PDFs.</p>';
      } else {
        // Hide the container if all files were removed
        fileListCont.style.display = 'none';
        pagesContainer.innerHTML = '<p style="color:#666; margin-top:100px; text-align:center; font-size:1.2rem;">' +
          'Drag & drop PDFs here, or use the file input above.<br>' +
          '<br>' +
          '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">' +
          '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>' +
          '<polyline points="14 2 14 8 20 8"></polyline>' +
          '<line x1="12" y1="18" x2="12" y2="12"></line>' +
          '<line x1="9" y1="15" x2="15" y2="15"></line>' +
          '</svg>' +
          '</p>';
      }
    }
    
    // Function to remove a PDF file from the list
    function removePdfFile(index) {
      // Remove the file from the array
      fileBlobs.splice(index, 1); // Fixed: This removes one element at position 'index'
      
      // Update the UI
      setupFileList();
      
      // Update data-index attributes on remove buttons to match new array indexes
      document.querySelectorAll('.remove-file-btn').forEach((btn, i) => {
        btn.dataset.index = i;
      });
      
      // Update data-index attributes on list items
      document.querySelectorAll('#file-list li').forEach((li, i) => {
        li.dataset.index = i;
      });
    }

    // when user clicks Load, render in the chosen order
    loadBtn.addEventListener('click', () => {
      if (fileBlobs.length === 0) {
        alert('Please add at least one PDF file before loading.');
        return;
      }
      
      const ordered = Array.from(fileListEl.children).map(li => fileBlobs[li.dataset.index]);
      renderMultiplePDFs(ordered);
    });

    // render 1+ PDFs in sequence
    async function renderMultiplePDFs(files) {
      pagesContainer.innerHTML = '';
      fabricCanvases = [];
      pdfCanvases = [];
      lastFocusedCanvas = null;
      
      // Reset selection mode
      selectionMode = false;
      toggleSelectionBtn.textContent = 'Select Pages';
      toggleSelectionBtn.style.background = '';
      pageSelectionCtrls.style.display = 'none';

      for (const file of files) {
        const url = URL.createObjectURL(file);
        const pdf = await pdfjsLib.getDocument(url).promise;
        for (let p = 1; p <= pdf.numPages; p++) {
          const page = await pdf.getPage(p);
          const vp   = page.getViewport({ scale: 1.5 });

          // container for this page
          const wrapper = document.createElement('div');
          wrapper.className = 'page-container';
          wrapper.style.width  = vp.width + 'px';
          wrapper.style.height = vp.height + 'px';

          // PDF layer
          const pdfCanv = document.createElement('canvas');
          pdfCanv.className = 'pdf-canvas';
          pdfCanv.width  = vp.width;
          pdfCanv.height = vp.height;
          wrapper.appendChild(pdfCanv);
          await page.render({ canvasContext: pdfCanv.getContext('2d'), viewport: vp }).promise;
          pdfCanvases.push(pdfCanv);

          // annotation layer
          const annCanv = document.createElement('canvas');
          annCanv.className = 'annotation-canvas';
          annCanv.width  = vp.width;
          annCanv.height = vp.height;
          wrapper.appendChild(annCanv);

          pagesContainer.appendChild(wrapper);
          const fc = new fabric.Canvas(annCanv, { selection: false });
          fabricCanvases.push(fc);

          // Selection configuration
          fc.selectionKey = 'shiftKey';
          fc.selectionColor = 'rgba(0, 168, 150, 0.2)';
          fc.selectionBorderColor = 'rgba(0, 168, 150, 0.8)';
          fc.selectionLineWidth = 1;

          // per-canvas handlers
          fc.on('mouse:down', opt => {
            lastFocusedCanvas = fc;
            const pt = fc.getPointer(opt.e, true);
            
            if (currentTool === 'line') {
              fc._line = new fabric.Line([pt.x,pt.y,pt.x,pt.y], {
                stroke: colorPicker.value,
                strokeWidth: +sizeSlider.value,
                selectable: false
              });
              fc.add(fc._line);
              
              // Track this action for undo
              undoHistory.push({
                canvasIndex: fabricCanvases.indexOf(fc),
                type: 'add',
                object: fc._line
              });
            } else if (currentTool === 'text') {
              const txt = new fabric.IText('', {  // Default text to edit
                left: pt.x, top: pt.y,
                fill: colorPicker.value,
                fontSize: +fontSizeInput.value
              });
              fc.add(txt).setActiveObject(txt);
              txt.enterEditing();
              txt.hiddenTextarea.focus();
              
              // Track this action for undo
              undoHistory.push({
                canvasIndex: fabricCanvases.indexOf(fc),
                type: 'add',
                object: txt
              });
            } else if (currentTool === 'highlight') {
              // Start drawing a highlight rectangle
              fc._highlightStart = pt;
              
              // Create a semi-transparent highlight rectangle
              const color = colorPicker.value;
              // Convert hex to RGB and add transparency
              let opacity = 0.3; // Default highlight opacity
              
              // Create a semi-transparent version of the selected color
              fc._highlight = new fabric.Rect({
                left: pt.x,
                top: pt.y,
                width: 0,
                height: 0,
                fill: color,
                opacity: opacity,
                selectable: true
              });
              fc.add(fc._highlight);
              
              // Don't add to undo history yet - will do on mouse up when the highlight is complete
            } else if (currentTool === 'select') {
              // Track original position of objects when selected
              const activeObj = fc.getActiveObject();
              if (activeObj) {
                // Store the original position
                activeObj._originalLeft = activeObj.left;
                activeObj._originalTop = activeObj.top;
                
                // Also store original scale, angle, etc.
                activeObj._originalState = {
                  scaleX: activeObj.scaleX,
                  scaleY: activeObj.scaleY,
                  angle: activeObj.angle,
                  width: activeObj.width,
                  height: activeObj.height
                };
              }
            }
          });
          
          fc.on('mouse:move', opt => {
            if (!opt.e.buttons) return; // Only process if mouse button is pressed
            
            const pt = fc.getPointer(opt.e, true);
            
            if (currentTool === 'line' && fc._line) {
              fc._line.set({ x2:pt.x, y2:pt.y });
              fc.renderAll();
            } else if (currentTool === 'highlight' && fc._highlight && fc._highlightStart) {
              // Calculate width and height based on start point and current point
              const width = Math.abs(pt.x - fc._highlightStart.x);
              const height = Math.abs(pt.y - fc._highlightStart.y);
              
              // Set the top-left corner of the rectangle
              const left = Math.min(fc._highlightStart.x, pt.x);
              const top = Math.min(fc._highlightStart.y, pt.y);
              
              fc._highlight.set({
                left: left,
                top: top,
                width: width,
                height: height
              });
              
              fc.renderAll();
            }
          });
          
          fc.on('mouse:up', () => {
            if (fc._line) { 
              fc._line.setCoords(); 
              fc._line = null; 
            }
            
            if (fc._highlight) {
              // Finalize the highlight
              fc._highlight.setCoords();
              
              // Add to undo history now that the highlight is complete
              undoHistory.push({
                canvasIndex: fabricCanvases.indexOf(fc),
                type: 'add',
                object: fc._highlight
              });
              
              // Clean up temporary variables
              fc._highlight = null;
              fc._highlightStart = null;
            }
          });
          
          // Track object modifications for undo
          fc.on('object:modified', (e) => {
            const obj = e.target;
            
            if (obj._originalLeft !== undefined && obj._originalTop !== undefined) {
              // This was a move operation
              undoHistory.push({
                canvasIndex: fabricCanvases.indexOf(fc),
                type: 'move',
                object: obj,
                oldLeft: obj._originalLeft,
                oldTop: obj._originalTop,
                newLeft: obj.left,
                newTop: obj.top
              });
              
              // Clean up temp properties
              delete obj._originalLeft;
              delete obj._originalTop;
            }
            
            if (obj._originalState) {
              // This was a transform operation (resize, rotate, etc)
              const newState = {
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                angle: obj.angle,
                width: obj.width,
                height: obj.height
              };
              
              // Only add to history if something actually changed
              let hasChanged = false;
              for (const prop in newState) {
                if (newState[prop] !== obj._originalState[prop]) {
                  hasChanged = true;
                  break;
                }
              }
              
              if (hasChanged) {
                undoHistory.push({
                  canvasIndex: fabricCanvases.indexOf(fc),
                  type: 'modify',
                  object: obj,
                  oldState: obj._originalState,
                  newState: newState
                });
              }
              
              // Clean up temp properties
              delete obj._originalState;
            }
          });
        }
      }
      updateToolMode();

      // Add this line:
      if (currentTool === 'select') {
        initializeMultiSelect();
      }

      function enableMultiSelectOnAllCanvases() {
      if (currentTool === 'select') {
        fabricCanvases.forEach(fc => {
          // Make sure selection is enabled
          fc.selection = true;
          
          // Make sure all objects are selectable
          fc.getObjects().forEach(o => {
            o.selectable = true;
            o.evented = true;
          });
          
          // Update the canvas
          fc.renderAll();
        });
      }
    }

    // Modify the tool switching event listener
    // Find the existing tool switching code:
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
        updateToolMode();
        
        // Add this line:
        if (currentTool === 'select') {
          initializeMultiSelect();
        }
      });
    });

    // Replace it with this updated version:
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
        updateToolMode();
        
        // If switching to select tool, ensure multiple selection is enabled
        if (currentTool === 'select') {
          enableMultiSelectOnAllCanvases();
        }
      });
    });
    }

    function toggleReorderMode() {
      if (!pdfCanvases.length) {
        alert('Please load a PDF first.');
        return;
      }

      reorderingMode = !reorderingMode;
      reorderPagesBtn.textContent = reorderingMode ? 'Exit Reorder Mode' : 'Reorder Pages';
      reorderPagesBtn.style.background = reorderingMode ? 'var(--secondary)' : '';
      
      // Toggle reordering class on container
      pagesContainer.classList.toggle('reordering', reorderingMode);
      
      if (reorderingMode) {
        // Disable the default PDF drag and drop behavior while in reordering mode
        pagesContainer.removeEventListener('dragover', pagesContainerDragOver);
        pagesContainer.removeEventListener('dragleave', pagesContainerDragLeave);
        pagesContainer.removeEventListener('drop', pagesContainerDrop);
        
        // Store current tool to restore later
        previousTool = currentTool;
        
        // Temporarily disable other tools during reordering
        toolButtons.forEach(btn => btn.classList.remove('active'));
        currentTool = 'reordering';
        
        // Store the current order as the original order
        originalPageOrder = [];
        for (let i = 0; i < pdfCanvases.length; i++) {
          originalPageOrder.push(i);
        }
        
        // Add page numbers to each page
        const pageContainers = document.querySelectorAll('.page-container');
        pageContainers.forEach((container, index) => {
          // Set data attribute to track original index
          container.dataset.originalIndex = index;
          
          // Add page number indicator if it doesn't exist
          if (!container.querySelector('.page-order-indicator')) {
            const indicator = document.createElement('div');
            indicator.className = 'page-order-indicator';
            indicator.textContent = `Page ${index + 1}`;
            container.appendChild(indicator);
          } else {
            // Update existing indicator
            container.querySelector('.page-order-indicator').textContent = `Page ${index + 1}`;
          }
        });
        
        // Disable fabric canvas interactivity during reordering
        fabricCanvases.forEach(fc => {
          fc.selection = false;
          fc.isDrawingMode = false;
          fc.forEachObject(obj => {
            obj.selectable = false;
            obj.evented = false;
          });
          fc.renderAll();
        });
        
        // Initialize Sortable.js on the pages container
        sortablePages = new Sortable(pagesContainer, {
          animation: 150,
          handle: '.page-container', // This selects the entire container
          draggable: '.page-container',
          ghostClass: 'dragging',
          onEnd: updatePageOrder,
          delay: 100, // Small delay to improve drag detection
          delayOnTouchOnly: true, // Only delay for touch devices
          touchStartThreshold: 5, // Distance threshold before drag starts
        });
        
        // Show reorder controls
        const reorderControls = document.createElement('div');
        reorderControls.className = 'reorder-controls';
        reorderControls.id = 'reorder-controls';
        
        const applyReorderBtn = document.createElement('button');
        applyReorderBtn.textContent = 'Apply New Order';
        applyReorderBtn.addEventListener('click', applyPageReordering);
        
        const cancelReorderBtn = document.createElement('button');
        cancelReorderBtn.textContent = 'Cancel';
        cancelReorderBtn.className = 'secondary-btn';
        cancelReorderBtn.addEventListener('click', cancelReordering);
        
        reorderControls.appendChild(applyReorderBtn);
        reorderControls.appendChild(cancelReorderBtn);
        document.body.appendChild(reorderControls);
        reorderControls.style.display = 'flex';
        
        // Prevent default behavior to avoid the popup
        pagesContainer.addEventListener('dragover', preventDefaultDragEvent);
        pagesContainer.addEventListener('drop', preventDefaultDragEvent);
      } else {
        exitReorderMode();
      }
    }

    function exitReorderMode() {
      // Exit reorder mode
      if (document.getElementById('reorder-controls')) {
        document.getElementById('reorder-controls').remove();
      }
      
      // Remove page indicators
      document.querySelectorAll('.page-order-indicator').forEach(indicator => {
        indicator.remove();
      });
      
      // Destroy Sortable instance
      if (sortablePages) {
        sortablePages.destroy();
        sortablePages = null;
      }
      
      // Restore original drag-and-drop event listeners for PDF loading
      pagesContainer.removeEventListener('dragover', preventDefaultDragEvent);
      pagesContainer.removeEventListener('drop', preventDefaultDragEvent);
      
      pagesContainer.addEventListener('dragover', pagesContainerDragOver);
      pagesContainer.addEventListener('dragleave', pagesContainerDragLeave);
      pagesContainer.addEventListener('drop', pagesContainerDrop);
      
      // Restore previous tool
      currentTool = previousTool;
      
      // Reactivate the appropriate tool button
      toolButtons.forEach(btn => {
        if (btn.dataset.tool === currentTool) {
          btn.classList.add('active');
        }
      });
      
      // Update tool mode
      updateToolMode();
    }

    function cancelReordering() {
      // Restore the original page order
      restoreOriginalOrder();
      
      // Exit reorder mode
      reorderingMode = false;
      reorderPagesBtn.textContent = 'Reorder Pages';
      reorderPagesBtn.style.background = '';
      pagesContainer.classList.remove('reordering');
      exitReorderMode();
    }

    function restoreOriginalOrder() {
      if (originalPageOrder.length === 0) return;
      
      // Create temporary arrays with the original order
      const restoredFabricCanvases = [];
      const restoredPdfCanvases = [];
      
      // Populate the arrays in the original order
      for (let i = 0; i < originalPageOrder.length; i++) {
        const currentIndex = originalPageOrder.indexOf(i);
        restoredFabricCanvases[i] = fabricCanvases[currentIndex];
        restoredPdfCanvases[i] = pdfCanvases[currentIndex];
      }
      
      // Replace the current arrays
      fabricCanvases = restoredFabricCanvases;
      pdfCanvases = restoredPdfCanvases;
      
      // Rebuild the DOM
      rebuildPagesDOM();
    }

    // Function to update page numbers after drag
    function updatePageOrder() {
      // Update all page number indicators
      const pageContainers = document.querySelectorAll('.page-container');
      pageContainers.forEach((container, index) => {
        const indicator = container.querySelector('.page-order-indicator');
        if (indicator) {
          indicator.textContent = `Page ${index + 1}`;
        }
      });
    }

    // Function to apply the new page order
    function applyPageReordering() {
      // Get the new order of pages
      const pageContainers = Array.from(document.querySelectorAll('.page-container'));
      
      // Create temporary arrays to store the new order
      const reorderedFabricCanvases = [];
      const reorderedPdfCanvases = [];
      
      // For each container in the new order, get its original index
      pageContainers.forEach(container => {
        const originalIndex = parseInt(container.dataset.originalIndex);
        reorderedFabricCanvases.push(fabricCanvases[originalIndex]);
        reorderedPdfCanvases.push(pdfCanvases[originalIndex]);
      });
      
      // Replace the original arrays with the reordered ones
      fabricCanvases = reorderedFabricCanvases;
      pdfCanvases = reorderedPdfCanvases;
      
      // Exit reorder mode
      reorderingMode = false;
      reorderPagesBtn.textContent = 'Reorder Pages';
      reorderPagesBtn.style.background = '';
      pagesContainer.classList.remove('reordering');
      if (document.getElementById('reorder-controls')) {
        document.getElementById('reorder-controls').remove();
      }
      
      // Rebuild the DOM with the new order
      rebuildPagesDOM();
    }

    // Function to rebuild the DOM with the current page order
    function rebuildPagesDOM() {
      // Save the scroll position
      const scrollPosition = window.scrollY;
      
      // Clear the container
      pagesContainer.innerHTML = '';
      
      // Add each page in the current order
      for (let i = 0; i < pdfCanvases.length; i++) {
        const pdfCanv = pdfCanvases[i];
        const fc = fabricCanvases[i];
        
        // Create a container for this page
        const wrapper = document.createElement('div');
        wrapper.className = 'page-container';
        wrapper.style.width = pdfCanv.width + 'px';
        wrapper.style.height = pdfCanv.height + 'px';
        
        // Add the PDF canvas
        wrapper.appendChild(pdfCanv);
        
        // Properly handle the fabric canvas
        wrapper.appendChild(fc.wrapperEl);
        
        // Add the complete page to the document
        pagesContainer.appendChild(wrapper);
        
        // Make sure fabric.js recalculates its position
        fc.setDimensions({
          width: pdfCanv.width,
          height: pdfCanv.height
        });
        fc.calcOffset();
        fc.requestRenderAll();
      }
      
      // Restore the scroll position
      window.scrollTo(0, scrollPosition);
    }

    // Simple function to prevent default drag events
    function preventDefaultDragEvent(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Store the previous tool to restore after reordering
    let previousTool = 'select';
  </script>
</body>
</html>