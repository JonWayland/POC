<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="../images/sand_dollar_favicon_64.png" sizes="64x64" type="image/png">
  <title>PNG to SVG Converter | The Dollar Web</title>
  <style>
    /* Inter and Montserrat Fonts */
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 400;
      src: url('/fonts/inter-regular.woff2') format('woff2');
    }
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 500;
      src: url('/fonts/inter-medium.woff2') format('woff2');
    }
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 600;
      src: url('/fonts/inter-semibold.woff2') format('woff2');
    }

    @font-face {
      font-family: 'Montserrat';
      font-style: normal;
      src: url('/fonts/Montserrat-VariableFont_wght.ttf') format('truetype-variations');
      font-weight: 100 900; /* This tells the browser this file contains all weights */
      font-display: swap;
    }

    @font-face {
      font-family: 'Montserrat';
      font-style: italic;
      src: url('/fonts/Montserrat-Italic-VariableFont_wght.ttf') format('truetype-variations');
      font-weight: 100 900;
      font-display: swap;
    }

    :root {
      --primary: #00a896;
      --secondary: #f8b500;
      --accent: #ff6b6b;
      --light: #f8f9fa;
      --dark: #05668d;
      --text: #333;
      --bg: #f5f9f8;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg);
      color: var(--text);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' opacity='0.03' viewBox='0 0 120 120'%3E%3Cpath d='M20,60 C20,60 35,30 60,30 C85,30 100,60 100,60 C100,60 85,90 60,90 C35,90 20,60 20,60 Z' fill='%2300a896'/%3E%3C/svg%3E");
      background-size: 120px;
      padding-top: 70px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 60px;
    }
    
    header {
      text-align: center;
      padding: 40px 0 0px;
    }
    
    h1 {
      font-family: 'Montserrat', sans-serif;
      font-size: 3.2rem;
      color: var(--primary);
      margin-bottom: 1.2rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      margin-top: 80px;
    }
    
    p.tagline {
      font-size: 1.3rem;
      color: var(--dark);
      max-width: 700px;
      margin: 0 auto 2rem;
      line-height: 1.6;
      font-weight: 300;
    }

    /* Navigation Bar Styles */
    .main-nav {
      background: white;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.08);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 2000;
    }

    .nav-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
    }

    .nav-logo {
      display: flex;
      align-items: center;
      text-decoration: none;
      color: var(--primary);
      font-weight: 600;
      font-size: 1.5rem;
      transition: all 0.2s;
    }

    .nav-logo:hover {
      transform: translateY(-2px);
    }

    .nav-logo svg {
      margin-right: 10px;
    }

    .nav-links {
      display: flex;
      align-items: center;
      gap: 30px;
    }

    .nav-links a {
      color: var(--dark);
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
    }

    .nav-links a:hover {
      color: var(--primary);
    }

    .login-btn {
      background: var(--primary);
      color: white !important;
      padding: 10px 20px;
      border-radius: 8px;
      transition: all 0.2s !important;
    }

    .login-btn:hover {
      background: var(--dark);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    /* Footer Styles */
    .site-footer {
      background: var(--dark);
      padding: 40px 0 50px;
      margin-top: 80px;
      position: relative;
      color: white;
    }

    .footer-wave {
      position: absolute;
      top: -120px;
      left: 0;
      right: 0;
      height: 120px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 120' width='1200' height='120' opacity='0.1'%3E%3Cpath d='M0,100 C200,20 400,60 600,80 C800,100 1000,40 1200,120 L1200,120 L0,120 Z' fill='%23ffffff'/%3E%3C/svg%3E");
      background-repeat: repeat-x;
      background-position: bottom;
    }

    .footer-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .footer-logo {
      display: flex;
      align-items: center;
      margin-bottom: 40px;
      color: var(--secondary);
    }

    .footer-logo svg {
      width: 48px;
      height: 48px;
      margin-right: 16px;
    }

    .footer-logo span {
      font-weight: 600;
      font-size: 2.4rem;
    }

    .footer-links {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 40px;
    }

    .footer-links a {
      color: var(--light);
      text-decoration: none;
      margin: 0 30px;
      font-size: 1.8rem;
      transition: color 0.2s;
    }

    .footer-links a:hover {
      color: var(--secondary);
    }

    .footer-social {
      display: flex;
      gap: 30px;
      margin-bottom: 40px;
    }

    .footer-social a {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      transition: all 0.2s;
    }

    .footer-social a svg {
      width: 40px;
      height: 40px;
    }

    .footer-social a:hover {
      background: var(--secondary);
      color: var(--dark);
      transform: translateY(-3px);
    }

    .copyright {
      font-size: 1.8rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .copyright-message {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .secondary-text {
      color: var(--secondary);
    }
    
    .tertiary-text {
      color: var(--dark);
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .nav-links {
        gap: 15px;
      }
      
      .nav-logo span {
        font-size: 1.2rem;
      }
      
      .footer-links {
        flex-direction: column;
        gap: 20px;
      }
      
      .footer-links a {
        margin: 10px 0;
      }
    }

    @media (max-width: 576px) {
      .nav-links a:not(.login-btn) {
        display: none;
      }
    }

    /* PNG to SVG Converter Specific Styles */
    .converter-box {
      background: white;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.06);
      padding: 40px;
      margin-top: 30px;
      text-align: center;
    }

    .file-upload-area {
      border: 2px dashed #ddd;
      border-radius: 12px;
      padding: 40px 20px;
      margin: 30px 0;
      transition: all 0.3s;
      cursor: pointer;
      position: relative;
    }

    .file-upload-area:hover {
      border-color: var(--primary);
      background: rgba(0, 168, 150, 0.05);
    }

    .file-upload-area input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    .upload-icon {
      margin-bottom: 20px;
    }

    .upload-text {
      font-size: 1.2rem;
      color: var(--dark);
      margin-bottom: 10px;
    }

    .upload-hint {
      font-size: 0.9rem;
      color: #666;
    }

    .preview-section {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      margin: 30px 0;
    }

    .preview-container {
      flex: 1;
      min-width: 300px;
      margin: 15px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      text-align: center;
    }

    .preview-title {
      font-size: 1.2rem;
      color: var(--dark);
      margin-bottom: 15px;
      font-weight: 500;
    }

    .preview-image {
      max-width: 100%;
      max-height: 300px;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .button-group {
      margin-top: 30px;
      text-align: center;
    }

    .convert-btn {
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 25px;
      font-size: 1.1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .convert-btn:hover {
      background: var(--dark);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .convert-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .download-btn {
      display: inline-block;
      background: var(--secondary);
      color: white;
      text-decoration: none;
      border: none;
      border-radius: 8px;
      padding: 12px 25px;
      font-size: 1.1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 20px;
    }

    .download-btn:hover {
      background: #e9a800;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .progress-indicator {
      display: none;
      margin: 20px auto;
      text-align: center;
    }

    .progress-spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid var(--primary);
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .settings-section {
      margin: 30px 0;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
    }

    .settings-title {
      font-size: 1.1rem;
      color: var(--dark);
      margin-bottom: 15px;
      font-weight: 500;
    }

    .settings-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
    }

    .settings-control {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .settings-label {
      font-size: 0.9rem;
      margin-bottom: 5px;
      color: var(--text);
    }

    .settings-input {
      width: 80px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      text-align: center;
    }

    .os-links {
      margin-top: 10px;
    }
    
    .os-links a {
      color: var(--primary); 
      text-decoration: none; 
      font-size: 0.9rem;
    }
    
    .os-links a:hover { 
      text-decoration: underline; 
    }
  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="main-nav">
    <div class="container nav-container">
      <a href="../index.html" class="nav-logo">
        <img src="../images/logo.svg" alt="The Dollar Web Logo" style="width: 32px; height: 32px;">
        <span class="tertiary-text">&nbsp;The&nbsp;</span>Dollar&nbsp;<span class="secondary-text">Web</span>
      </a>
      <div class="nav-links">
        <a href="../index.html">Home</a>
        <a href="../tools.html">Tools</a>
        <a href="../about.html">About</a>
        <a href="../login.html" class="login-btn">Login</a>
      </div>
    </div>
  </nav>

  <div class="container">
    <header>
      <h1>PNG to SVG Converter</h1>
      <p class="tagline">Transform raster images (PNG, JPG) into scalable vector graphics (SVG). Perfect for logos, icons, and illustrations that need to be resized without losing quality.</p>
      <div class="os-links">
        <a href="/licenses.html">Open-source acknowledgements</a>
      </div>
    </header>

    <div class="converter-box">
      <div class="file-upload-area" id="upload-area">
        <input type="file" id="imageInput" accept=".png,.jpg,.jpeg">
        <div class="upload-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#05668d" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
        </div>
        <div class="upload-text">Click or drag an image file here</div>
        <div class="upload-hint">Supports PNG and JPG/JPEG files</div>
      </div>

      <div class="settings-section" id="settings-section" style="display: none;">
        <div class="settings-title">Conversion Settings</div>
        <div class="settings-group">
          <div class="settings-control">
            <label class="settings-label" for="ltres">Line Threshold</label>
            <input type="range" id="ltres" class="settings-input" min="0.1" max="5" step="0.1" value="1">
            <span id="ltres-value">1</span>
          </div>
          <div class="settings-control">
            <label class="settings-label" for="qtres">Curve Threshold</label>
            <input type="range" id="qtres" class="settings-input" min="0.1" max="5" step="0.1" value="1">
            <span id="qtres-value">1</span>
          </div>
          <div class="settings-control">
            <label class="settings-label" for="scale">Output Scale</label>
            <input type="range" id="scale" class="settings-input" min="0.5" max="3" step="0.1" value="1">
            <span id="scale-value">1</span>
          </div>
        </div>
      </div>

      <div class="preview-section">
        <div class="preview-container" id="raster-container" style="display: none;">
          <div class="preview-title">Original Image</div>
          <div id="rasterPreview"></div>
        </div>
        <div class="preview-container" id="svg-container" style="display: none;">
          <div class="preview-title">SVG Result</div>
          <div id="svgPreview"></div>
        </div>
      </div>

      <div class="progress-indicator" id="progress-indicator">
        <div class="progress-spinner"></div>
        <div class="progress-text">Converting image to SVG...</div>
      </div>

      <div class="button-group">
        <button id="convertBtn" class="convert-btn" disabled>Convert to SVG</button>
        <br>
        <a id="downloadLink" class="download-btn" style="display: none;">Download SVG</a>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <footer class="site-footer">
    <div class="footer-wave"></div>
    <div class="footer-content">
      <div class="footer-logo">
        <img src="../images/logo.svg" alt="The Dollar Web Logo" style="width: 48px; height: 48px;">
        <span>&nbsp;The Dollar Web</span>
      </div>
      <div class="footer-links">
        <a href="../index.html">Home</a>
        <a href="../about.html">About</a>
        <a href="../contact.html">Contact</a>
        <a href="../privacy.html">Privacy Policy</a>
        <a href="../terms.html">Terms of Service</a>
      </div>
      <div class="footer-social">
        <a href="https://x.com/thedollarweb" aria-label="Twitter">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Z"/>
          </svg>
        </a>
        <a href="https://www.instagram.com/thedollarwebpro/" aria-label="Instagram">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
            <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
            <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
          </svg>
        </a>
        <a href="https://www.linkedin.com/company/the-dollar-web" aria-label="LinkedIn">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
            <rect x="2" y="9" width="4" height="12"></rect>
            <circle cx="4" cy="4" r="2"></circle>
          </svg>
        </a>
      </div>
      <p class="copyright">&copy; 2025 The DollarWeb</p>
      <p class="copyright-message">Professional tools that won't break the bank</p>
    </div>
  </footer>

  <script>
    const MAX_WIDTH = 800;
    const imageInput = document.getElementById('imageInput');
    const rasterPreview = document.getElementById('rasterPreview');
    const svgPreview = document.getElementById('svgPreview');
    const convertBtn = document.getElementById('convertBtn');
    const downloadLink = document.getElementById('downloadLink');
    const rasterContainer = document.getElementById('raster-container');
    const svgContainer = document.getElementById('svg-container');
    const progressIndicator = document.getElementById('progress-indicator');
    const settingsSection = document.getElementById('settings-section');
    const uploadArea = document.getElementById('upload-area');

    // Settings inputs
    const ltresInput = document.getElementById('ltres');
    const qtresInput = document.getElementById('qtres');
    const scaleInput = document.getElementById('scale');
    const ltresValue = document.getElementById('ltres-value');
    const qtresValue = document.getElementById('qtres-value');
    const scaleValue = document.getElementById('scale-value');

    let workingCanvas = document.createElement('canvas');
    let currentImage = null;

    // Update settings value displays
    ltresInput.addEventListener('input', () => {
      ltresValue.textContent = ltresInput.value;
    });

    qtresInput.addEventListener('input', () => {
      qtresValue.textContent = qtresInput.value;
    });

    scaleInput.addEventListener('input', () => {
      scaleValue.textContent = scaleInput.value;
    });

    // Handle drag & drop events
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.style.borderColor = 'var(--primary)';
      uploadArea.style.background = 'rgba(0, 168, 150, 0.1)';
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.style.borderColor = '#ddd';
      uploadArea.style.background = 'transparent';
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.style.borderColor = '#ddd';
      uploadArea.style.background = 'transparent';
      
      if (e.dataTransfer.files.length > 0) {
        imageInput.files = e.dataTransfer.files;
        handleImageUpload(e.dataTransfer.files[0]);
      }
    });

    imageInput.addEventListener('change', () => {
      const file = imageInput.files[0];
      if (!file) return;
      handleImageUpload(file);
    });

    function handleImageUpload(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      
      img.onload = () => {
        // Scale down if too wide
        const scale = Math.min(1, MAX_WIDTH / img.width);
        workingCanvas.width = img.width * scale;
        workingCanvas.height = img.height * scale;
        const ctx = workingCanvas.getContext('2d');
        ctx.clearRect(0, 0, workingCanvas.width, workingCanvas.height);
        ctx.drawImage(img, 0, 0, workingCanvas.width, workingCanvas.height);

        // Show raster preview
        rasterPreview.innerHTML = '';
        const previewImg = new Image();
        previewImg.src = workingCanvas.toDataURL();
        previewImg.className = 'preview-image';
        rasterPreview.appendChild(previewImg);

        currentImage = workingCanvas;
        convertBtn.disabled = false;
        
        // Show the relevant containers
        rasterContainer.style.display = 'block';
        settingsSection.style.display = 'block';
        
        // Reset the SVG preview
        svgPreview.innerHTML = '';
        svgContainer.style.display = 'none';
        downloadLink.style.display = 'none';
      };
      
      img.src = url;
    }

    // Function to get colors from the image using k-means clustering
    function extractDominantColors(imageData, numColors = 8) {
      const pixels = [];
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      
      // Sample pixels (for performance, don't use every pixel)
      const sampleRate = Math.max(1, Math.floor(Math.sqrt(width * height) / 100));
      
      for (let y = 0; y < height; y += sampleRate) {
        for (let x = 0; x < width; x += sampleRate) {
          const i = (y * width + x) * 4;
          // Skip transparent pixels
          if (data[i + 3] < 10) continue;
          
          pixels.push([data[i], data[i + 1], data[i + 2]]);
        }
      }
      
      // If we don't have enough pixels, return early
      if (pixels.length < numColors) {
        return pixels.map(p => ({ r: p[0], g: p[1], b: p[2], color: `rgb(${p[0]},${p[1]},${p[2]})` }));
      }
      
      // Initialize centroids with k-means++ method
      const centroids = [pixels[Math.floor(Math.random() * pixels.length)]];
      
      // Choose remaining centroids
      for (let i = 1; i < numColors; i++) {
        // Calculate distances to existing centroids
        const distances = pixels.map(pixel => {
          return Math.min(...centroids.map(centroid => 
            Math.sqrt(
              Math.pow(pixel[0] - centroid[0], 2) + 
              Math.pow(pixel[1] - centroid[1], 2) + 
              Math.pow(pixel[2] - centroid[2], 2)
            )
          ));
        });
        
        // Choose the next centroid with probability proportional to distance squared
        const totalDistance = distances.reduce((sum, dist) => sum + Math.pow(dist, 2), 0);
        let target = Math.random() * totalDistance;
        let sum = 0;
        
        for (let j = 0; j < distances.length; j++) {
          sum += Math.pow(distances[j], 2);
          if (sum >= target) {
            centroids.push(pixels[j]);
            break;
          }
        }
      }
      
      // Run k-means algorithm (max 10 iterations)
      for (let iter = 0; iter < 10; iter++) {
        // Assign pixels to clusters
        const clusters = Array(numColors).fill().map(() => []);
        
        for (const pixel of pixels) {
          let minDist = Infinity;
          let clusterId = 0;
          
          for (let i = 0; i < centroids.length; i++) {
            const dist = Math.sqrt(
              Math.pow(pixel[0] - centroids[i][0], 2) + 
              Math.pow(pixel[1] - centroids[i][1], 2) + 
              Math.pow(pixel[2] - centroids[i][2], 2)
            );
            
            if (dist < minDist) {
              minDist = dist;
              clusterId = i;
            }
          }
          
          clusters[clusterId].push(pixel);
        }
        
        // Update centroids
        let changed = false;
        for (let i = 0; i < centroids.length; i++) {
          if (clusters[i].length === 0) continue;
          
          const newCentroid = [0, 0, 0];
          for (const pixel of clusters[i]) {
            newCentroid[0] += pixel[0];
            newCentroid[1] += pixel[1];
            newCentroid[2] += pixel[2];
          }
          
          newCentroid[0] = Math.round(newCentroid[0] / clusters[i].length);
          newCentroid[1] = Math.round(newCentroid[1] / clusters[i].length);
          newCentroid[2] = Math.round(newCentroid[2] / clusters[i].length);
          
          // Check if centroid changed
          if (newCentroid[0] !== centroids[i][0] || 
              newCentroid[1] !== centroids[i][1] || 
              newCentroid[2] !== centroids[i][2]) {
            changed = true;
            centroids[i] = newCentroid;
          }
        }
        
        // If centroids didn't change, we've converged
        if (!changed) break;
      }
      
      // Calculate cluster sizes (popularity)
      const colorCounts = Array(numColors).fill(0);
      for (const pixel of pixels) {
        let minDist = Infinity;
        let clusterId = 0;
        
        for (let i = 0; i < centroids.length; i++) {
          const dist = Math.sqrt(
            Math.pow(pixel[0] - centroids[i][0], 2) + 
            Math.pow(pixel[1] - centroids[i][1], 2) + 
            Math.pow(pixel[2] - centroids[i][2], 2)
          );
          
          if (dist < minDist) {
            minDist = dist;
            clusterId = i;
          }
        }
        
        colorCounts[clusterId]++;
      }
      
      // Return colors with counts
      return centroids.map((centroid, i) => {
        return {
          r: centroid[0],
          g: centroid[1],
          b: centroid[2],
          color: `rgb(${centroid[0]},${centroid[1]},${centroid[2]})`,
          count: colorCounts[i]
        };
      }).sort((a, b) => b.count - a.count); // Sort by popularity
    }

    // Marching squares algorithm to extract contours
    function marchingSquares(imageData, color, threshold = 20) {
      const width = imageData.width;
      const height = imageData.height;
      const data = imageData.data;
      const target = [color.r, color.g, color.b];
      
      // Create a grid where 1 = pixel matches target color, 0 = doesn't match
      const grid = Array(height + 1).fill().map(() => Array(width + 1).fill(0));
      
      // Fill the grid based on color matching
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const a = data[i + 3];
          
          // Skip transparent pixels
          if (a < 128) continue;
          
          // Check if color matches within threshold
          const colorDist = Math.sqrt(
            Math.pow(r - target[0], 2) + 
            Math.pow(g - target[1], 2) + 
            Math.pow(b - target[2], 2)
          );
          
          if (colorDist <= threshold) {
            grid[y][x] = 1;
          }
        }
      }
      
      // Initialize contour finding
      const contours = [];
      const visited = Array(height).fill().map(() => Array(width).fill(false));
      
      // Directions for 8-connected components: clockwise from right
      const dx = [1, 1, 0, -1, -1, -1, 0, 1];
      const dy = [0, 1, 1, 1, 0, -1, -1, -1];
      
      // Find contours
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (bitmap[y][x] === 1 && !visited[y][x]) {
            const contour = [];
            
            // Start from this point
            let currX = x;
            let currY = y;
            
            // Trace the contour
            let foundNext = true;
            while (foundNext) {
              contour.push({ x: currX, y: currY });
              visited[currY][currX] = true;
              
              foundNext = false;
              
              // Try to find the next unvisited filled pixel
              for (let i = 0; i < 8; i++) {
                const newX = currX + dx[i];
                const newY = currY + dy[i];
                
                if (newX >= 0 && newX < width && newY >= 0 && newY < height && 
                    bitmap[newY][newX] === 1 && !visited[newY][newX]) {
                  currX = newX;
                  currY = newY;
                  foundNext = true;
                  break;
                }
              }
            }
            
            if (contour.length > 10) { // Ignore very small contours
              contours.push(contour);
            }
          }
        }
      }
      
      return contours;
    }

    // Function to simplify a contour using the Ramer-Douglas-Peucker algorithm
    function simplifyContour(contour, tolerance) {
      if (contour.length <= 2) return contour;
      
      // Find the point with the maximum distance
      let maxDistance = 0;
      let maxIndex = 0;
      
      const firstPoint = contour[0];
      const lastPoint = contour[contour.length - 1];
      
      for (let i = 1; i < contour.length - 1; i++) {
        const distance = perpendicularDistance(contour[i], firstPoint, lastPoint);
        if (distance > maxDistance) {
          maxDistance = distance;
          maxIndex = i;
        }
      }
      
      // If max distance is greater than tolerance, recursively simplify
      if (maxDistance > tolerance) {
        const firstPart = simplifyContour(contour.slice(0, maxIndex + 1), tolerance);
        const secondPart = simplifyContour(contour.slice(maxIndex), tolerance);
        
        // Concatenate the two parts (remove duplicate point)
        return firstPart.slice(0, -1).concat(secondPart);
      } else {
        // Return just the endpoints
        return [firstPoint, lastPoint];
      }
    }

    // Calculate perpendicular distance from point to line
    function perpendicularDistance(point, lineStart, lineEnd) {
      const dx = lineEnd.x - lineStart.x;
      const dy = lineEnd.y - lineStart.y;
      
      // If line is just a point, return distance to that point
      if (dx === 0 && dy === 0) {
        const distance = Math.sqrt(
          Math.pow(point.x - lineStart.x, 2) +
          Math.pow(point.y - lineStart.y, 2)
        );
        return distance;
      }
      
      // Calculate perpendicular distance
      const normalLength = Math.sqrt(dx * dx + dy * dy);
      return Math.abs(
        (point.y - lineStart.y) * dx - (point.x - lineStart.x) * dy
      ) / normalLength;
    }

    // Function to convert contour to SVG path
    function contourToPath(contour) {
      if (contour.length < 2) return '';
      
      let path = `M${contour[0].x},${contour[0].y}`;
      
      for (let i = 1; i < contour.length; i++) {
        path += ` L${contour[i].x},${contour[i].y}`;
      }
      
      path += ' Z'; // Close the path
      return path;
    }

    // Convert an image to SVG using color quantization and contour tracing
    function convertImageToSVG(imageData, options) {
      const scale = options.scale || 1;
      const simplifyTolerance = options.qtres || 1;
      const colorTolerance = options.ltres * 30 || 30; // Use line threshold for color matching
      
      // Get dominant colors from the image
      const dominantColors = getDominantColors(imageData, 10);
      
      // Create SVG paths for each color
      let svgPaths = [];
      
      for (const colorInfo of dominantColors) {
        // Skip colors that aren't significantly present
        if (colorInfo.count < (imageData.width * imageData.height * 0.001)) continue;
        
        // Create a mask for this color
        const colorMask = createColorMask(
          imageData, 
          colorInfo.r, 
          colorInfo.g, 
          colorInfo.b,
          colorTolerance // Use the line threshold setting to control color matching
        );
        
        // Trace contours for this color
        const contours = traceShapes(colorMask);
        
        // Simplify contours and convert to paths
        for (const contour of contours) {
          // Skip tiny contours
          if (contour.length < 10) continue;
          
          const simplifiedContour = simplifyContour(contour, simplifyTolerance);
          const path = contourToPath(simplifiedContour);
          
          if (path) {
            svgPaths.push({
              path: path,
              color: colorInfo.color,
              area: contour.length // Use contour length as a proxy for area
            });
          }
        }
      }
      
      // Sort paths by area (larger areas first - will be drawn first)
      svgPaths.sort((a, b) => b.area - a.area);
      
      // Generate SVG string
      const width = imageData.width * scale;
      const height = imageData.height * scale;
      
      let svgString = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${imageData.width} ${imageData.height}" width="${width}" height="${height}">`;
      
      // Add paths to SVG
      for (const pathInfo of svgPaths) {
        svgString += `<path d="${pathInfo.path}" fill="${pathInfo.color}" />`;
      }
      
      svgString += '</svg>';
      
      return svgString;
    }

    convertBtn.addEventListener('click', function() {
      if (!currentImage) return;
      
      // Show progress indicator
      progressIndicator.style.display = 'block';
      convertBtn.disabled = true;
      
      // Get image data from canvas
      const ctx = workingCanvas.getContext('2d');
      const imgData = ctx.getImageData(0, 0, workingCanvas.width, workingCanvas.height);
      
      // Get conversion settings
      const options = {
        ltres: parseFloat(ltresInput.value), // Use for color matching tolerance
        qtres: parseFloat(qtresInput.value), // Use for simplification tolerance
        scale: parseFloat(scaleInput.value)  // Output scale
      };
      
      // Use a web worker for better performance
      const workerCode = `
        self.onmessage = function(e) {
          const imageData = e.data.imageData;
          const options = e.data.options;
          
          // Function to get dominant colors from image data
          function getDominantColors(imageData, maxColors = 8) {
            const colorCounts = {};
            const data = imageData.data;
            
            // Count colors (ignoring fully transparent pixels)
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const a = data[i + 3];
              
              // Skip fully transparent pixels
              if (a < 10) continue;
              
              // Simplify colors slightly to reduce the number of unique colors
              const quantizedR = Math.round(r / 10) * 10;
              const quantizedG = Math.round(g / 10) * 10;
              const quantizedB = Math.round(b / 10) * 10;
              
              const colorKey = \`\${quantizedR},\${quantizedG},\${quantizedB}\`;
              
              if (colorCounts[colorKey]) {
                colorCounts[colorKey].count++;
                // Track original RGB values for more accurate color
                colorCounts[colorKey].totalR += r;
                colorCounts[colorKey].totalG += g;
                colorCounts[colorKey].totalB += b;
              } else {
                colorCounts[colorKey] = {
                  count: 1,
                  totalR: r,
                  totalG: g,
                  totalB: b
                };
              }
            }
            
            // Convert to array and sort by frequency
            const colorsArray = Object.keys(colorCounts).map(key => {
              const color = colorCounts[key];
              const avgR = Math.round(color.totalR / color.count);
              const avgG = Math.round(color.totalG / color.count);
              const avgB = Math.round(color.totalB / color.count);
              return {
                color: \`rgb(\${avgR},\${avgG},\${avgB})\`,
                count: color.count,
                r: avgR,
                g: avgG,
                b: avgB
              };
            });
            
            colorsArray.sort((a, b) => b.count - a.count);
            
            // Return top colors
            return colorsArray.slice(0, maxColors);
          }

          // Function to create a mask for a specific color range
          function createColorMask(imageData, targetR, targetG, targetB, tolerance = 30) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            // Create a 2D bitmap for the mask (1 = filled, 0 = empty)
            const maskBitmap = new Array(height);
            for (let y = 0; y < height; y++) {
              maskBitmap[y] = new Array(width).fill(0);
            }
            
            // Fill the bitmap based on color matching
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // Skip fully transparent pixels
                if (a < 10) continue;
                
                // Check if the color matches the target color within tolerance
                const rDiff = Math.abs(r - targetR);
                const gDiff = Math.abs(g - targetG);
                const bDiff = Math.abs(b - targetB);
                
                if (rDiff <= tolerance && gDiff <= tolerance && bDiff <= tolerance) {
                  maskBitmap[y][x] = 1;
                }
              }
            }
            
            return maskBitmap;
          }

          // Function to trace the outline of shapes in a bitmap
          function traceShapes(bitmap) {
            const width = bitmap[0].length;
            const height = bitmap.length;
            
            // Find contours using a simple algorithm
            const contours = [];
            const visited = new Array(height);
            for (let y = 0; y < height; y++) {
              visited[y] = new Array(width).fill(false);
            }
            
            // Check 8 neighbors around a point
            const dx = [-1, 0, 1, 1, 1, 0, -1, -1];
            const dy = [-1, -1, -1, 0, 1, 1, 1, 0];
            
            // Find contours
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                if (bitmap[y][x] === 1 && !visited[y][x]) {
                  const contour = [];
                  
                  // Start from this point
                  let currX = x;
                  let currY = y;
                  
                  // Trace the contour
                  let foundNext = true;
                  while (foundNext) {
                    contour.push({ x: currX, y: currY });
                    visited[currY][currX] = true;
                    
                    foundNext = false;
                    
                    // Try to find the next unvisited filled pixel
                    for (let i = 0; i < 8; i++) {
                      const newX = currX + dx[i];
                      const newY = currY + dy[i];
                      
                      if (newX >= 0 && newX < width && newY >= 0 && newY < height && 
                          bitmap[newY][newX] === 1 && !visited[newY][newX]) {
                        currX = newX;
                        currY = newY;
                        foundNext = true;
                        break;
                      }
                    }
                  }
                  
                  if (contour.length > 10) { // Ignore very small contours
                    contours.push(contour);
                  }
                }
              }
            }
            
            return contours;
          }

          // Function to simplify a contour using the Ramer-Douglas-Peucker algorithm
          function simplifyContour(contour, tolerance) {
            if (contour.length <= 2) return contour;
            
            // Find the point with the maximum distance
            let maxDistance = 0;
            let maxIndex = 0;
            
            const firstPoint = contour[0];
            const lastPoint = contour[contour.length - 1];
            
            // Calculate perpendicular distance from each point to the line
            for (let i = 1; i < contour.length - 1; i++) {
              const point = contour[i];
              const dx = lastPoint.x - firstPoint.x;
              const dy = lastPoint.y - firstPoint.y;
              
              // Calculate perpendicular distance
              let distance;
              if (dx === 0 && dy === 0) {
                // If line is just a point, use direct distance
                distance = Math.sqrt(
                  Math.pow(point.x - firstPoint.x, 2) +
                  Math.pow(point.y - firstPoint.y, 2)
                );
              } else {
                const normalLength = Math.sqrt(dx * dx + dy * dy);
                distance = Math.abs(
                  (point.y - firstPoint.y) * dx - (point.x - firstPoint.x) * dy
                ) / normalLength;
              }
              
              if (distance > maxDistance) {
                maxDistance = distance;
                maxIndex = i;
              }
            }
            
            // If max distance is greater than tolerance, recursively simplify
            if (maxDistance > tolerance) {
              const firstPart = simplifyContour(contour.slice(0, maxIndex + 1), tolerance);
              const secondPart = simplifyContour(contour.slice(maxIndex), tolerance);
              
              // Concatenate the two parts (remove duplicate point)
              return firstPart.slice(0, -1).concat(secondPart);
            } else {
              // Return just the endpoints
              return [firstPoint, lastPoint];
            }
          }

          // Function to convert contour to SVG path
          function contourToPath(contour) {
            if (contour.length < 2) return '';
            
            let path = \`M\${contour[0].x},\${contour[0].y}\`;
            
            for (let i = 1; i < contour.length; i++) {
              path += \` L\${contour[i].x},\${contour[i].y}\`;
            }
            
            path += ' Z'; // Close the path
            return path;
          }

          // Convert image to SVG
          function convertImageToSVG() {
            const scale = options.scale || 1;
            const simplifyTolerance = options.qtres || 1;
            const colorTolerance = options.ltres * 30 || 30;
            
            // Get dominant colors from the image
            const dominantColors = getDominantColors(imageData, 10);
            
            // Create SVG paths for each color
            let svgPaths = [];
            
            for (const colorInfo of dominantColors) {
              // Skip colors that aren't significantly present
              if (colorInfo.count < (imageData.width * imageData.height * 0.001)) continue;
              
              // Create a mask for this color
              const colorMask = createColorMask(
                imageData, 
                colorInfo.r, 
                colorInfo.g, 
                colorInfo.b,
                colorTolerance
              );
              
              // Trace contours for this color
              const contours = traceShapes(colorMask);
              
              // Simplify contours and convert to paths
              for (const contour of contours) {
                // Skip tiny contours
                if (contour.length < 10) continue;
                
                const simplifiedContour = simplifyContour(contour, simplifyTolerance);
                const path = contourToPath(simplifiedContour);
                
                if (path) {
                  svgPaths.push({
                    path: path,
                    color: colorInfo.color,
                    area: contour.length // Use contour length as a proxy for area
                  });
                }
              }
            }
            
            // Sort paths by area (larger areas first - will be drawn first)
            svgPaths.sort((a, b) => b.area - a.area);
            
            // Generate SVG string
            const width = imageData.width * scale;
            const height = imageData.height * scale;
            
            let svgString = \`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 \${imageData.width} \${imageData.height}" width="\${width}" height="\${height}">\`;
            
            // Add paths to SVG
            for (const pathInfo of svgPaths) {
              svgString += \`<path d="\${pathInfo.path}" fill="\${pathInfo.color}" />\`;
            }
            
            svgString += '</svg>';
            
            return svgString;
          }
          
          try {
            const svgString = convertImageToSVG();
            self.postMessage({ success: true, svg: svgString });
          } catch (err) {
            self.postMessage({ success: false, error: err.message });
          }
        };
      `;
      
      // Create a blob from the worker code
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const workerUrl = URL.createObjectURL(blob);
      const worker = new Worker(workerUrl);
      
      // Handle messages from worker
      worker.onmessage = function(e) {
        if (e.data.success) {
          // Display SVG preview
          svgPreview.innerHTML = e.data.svg;
          
          // Add class to SVG element for styling
          const svgElement = svgPreview.querySelector('svg');
          if (svgElement) {
            svgElement.classList.add('preview-image');
          }
          
          // Show SVG container
          svgContainer.style.display = 'block';
          
          // Prepare download
          const blob = new Blob([e.data.svg], { type: 'image/svg+xml' });
          const url = URL.createObjectURL(blob);
          downloadLink.href = url;
          downloadLink.download = 'vectorized.svg';
          downloadLink.style.display = 'inline-block';
        } else {
          console.error('Error processing image:', e.data.error);
          alert('Error converting image: ' + e.data.error);
        }
        
        // Hide progress indicator
        progressIndicator.style.display = 'none';
        convertBtn.disabled = false;
        
        // Cleanup
        worker.terminate();
        URL.revokeObjectURL(workerUrl);
      };
      
      // Handle worker errors
      worker.onerror = function(err) {
        console.error('Worker error:', err);
        alert('Error processing image. Please try again with different settings.');
        
        // Hide progress indicator
        progressIndicator.style.display = 'none';
        convertBtn.disabled = false;
        
        // Cleanup
        worker.terminate();
        URL.revokeObjectURL(workerUrl);
      };
      
      // Start the worker
      worker.postMessage({
        imageData: imgData,
        options: options
      });
    });

    // Add visual feedback for file upload area
    imageInput.addEventListener('focus', () => {
      uploadArea.style.borderColor = 'var(--primary)';
    });

    imageInput.addEventListener('blur', () => {
      uploadArea.style.borderColor = '#ddd';
    });
  </script>
</body>
</html>